#ifndef POWER_H
#define POWER_H

//#include <boost/numeric/conversion/cast.hpp>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_rng.h>
#include <kernel.h>
#include <dgp.h>
#include <dist_corr.h>

using namespace std;

class Power : public Dist_corr {
	public:
		Power (){  }; //default constructor
		~Power () { };//default destructor
		//calculate empirical powers of the t-test
		template <double kernel (double), void dgp (Matrix &, Matrix &, double, unsigned long)>
        double power_f (int, int, int, int, int, int, int, double, double, unsigned long, ofstream &);
		//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Gaussian AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
        //AR slopes (beta and lambda), standard deviations (sigma), degree of cross-sectional dependence (rho), empirical critical values (empir_CV), 
        //asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
		//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
        template <double kernel (double)>
        void power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                      const Matrix &lambda, const Matrix &sigma, double rho, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out);
        //calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate correlated Gaussian AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
        //AR slopes (beta and lambda), standard deviations (sigma), degree of cross-sectional dependence (rho), empirical critical values (empir_CV), 
        //asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
        //OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
        template <double kernel (double)>
        void power_CAR (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                        const Matrix &lambda, const Matrix &sigma, double rho, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out);
        //calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Student's t AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
        //AR slopes (beta and lambda), degrees of freedom (nu), standard deviations (sigma), degree of cross-sectional dependence (rho), 
		//empirical critical values (empir_CV), asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
		//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
        template <double kernel (double)>
        void power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
		              const Matrix &lambda, double nu, const Matrix &sigma, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out);
		//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when X is generated by a Gaussian AR(2) process and 
        //Y is generated by a bivariate Gaussian AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a sample size (T), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), 
        //a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y), 3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms
        //(sigma(1) for X, and sigma(2) for the error term (xi) of Y), a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, 
        //a threshold value (threshold) to generate some dependence between X and Y, empirical critical values (empir_CV), asymptotic critical values (asymp_CV), 
        //a seed to generate random variables (seed), a file output stream (pwr_out). 
        //OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
        template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, const Matrix &, double, double, unsigned long ), double kernel (double)>
        void power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                      const Matrix &lambda, const Matrix &sigma, double rho, double threshold, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, 
					  ofstream &pwr_out);
        //calculate 5% and 10% empirical critical values when data are generated by a bivariate Gaussian AR(2) process. INPUT: number of random samples
        //generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha), AR slopes (beta and lambda),
        //standard deviations (sigma), a seed for random generators (seed), an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv)
        template <double kernel (double)>
        Matrix cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, unsigned long seed, 
                       ofstream &size_out);
        //calculate 5% and 10% empirical critical values when data are generated by a bivariate Student's t AR(2) process. INPUT: number of random samples
        //generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha), AR slopes (beta and lambda),
        //degrees of freedom (nu), standard deviations (sigma), a cdf value (cdfVal) set to 0.95 for a 5% critical value and 0.90 for a 10% critical value,
        //a seed for random generators (seed), an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv)
        template <double kernel (double)>
        Matrix cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, double nu, const Matrix &sigma, 
                       unsigned long seed, ofstream &size_out);
        //calculate 5% and 10% empirical critical values when X is generated by a Gaussian AR(2) process and Y is generated by a bivariate Gaussian AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), 
        //a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y), 3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms
        //(sigma(1) for X, and sigma(2) for the error term (xi) of Y), a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a seed for random generators (seed), 
        //and an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv)
        template <double kernel (double)>
        Matrix cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, double rho, 
                       unsigned long seed, ofstream &size_out);
};


template <double kernel (double), void dgp (Matrix &, Matrix &, double, unsigned long)>
double Power::power_f (int number_sampl, int T, int d_x, int d_y, int K, int bsize, int bandwidth, double alpha, double ddep, unsigned long seed, ofstream &pwr_out)
//K is the number of random blocks each with size (bsize);
//bandwidth is a kernel bandwidth (1 < bandwidth < bsize);
//nbootstrp is number of samplings; T is the number of time periods; d_x is the dimension of X and d_x is the dimension of Y
//bandwidth is a kernel bandwidth (1 < bandwidth < bsize)
//alpha is the exponent of the correlation distance
//ddep is the amount of dependence
{
	int i, nrej = 0;
	double tvalue = 0., pvalue;
	Matrix X(T,d_x), Y(T,d_y);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed;
    cout << "Calculating the t-statistic ..." << endl;
	#pragma omp parallel for default(shared) reduction (+:nrej) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,tvalue)
	for (i = 1; i <= number_sampl; i++)
	{
		rseed = gsl_rng_get (r);
		dgp (X, Y, ddep, rseed);//draw two random samples for X and Y
		Dist_corr obj_dc (X,Y);//calculate the t-test statistic
        tvalue = obj_dc.t_test <kernel> (K, bsize, bandwidth, alpha, rseed);
        pwr_out << tvalue << endl;
        cout << tvalue << endl;
        if (tvalue >= 1.64) nrej += 1;
	}
	gsl_rng_free (r);
	pvalue = ((double) nrej/number_sampl);
	pwr_out << "Rej. frequency = " << pvalue << endl;
	return ((double) nrej/number_sampl);
}

//calculate 5% and 10% empirical critical values when data are generated by a bivariate Gaussian AR(2) process. INPUT: number of random samples
//generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha), AR slopes (beta and lambda),
//standard deviations (sigma), a seed for random generators (seed), an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv)
template <double kernel (double)>
Matrix Power::cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, unsigned long seed, 
                      ofstream &size_out) {
	Matrix X(T, 1), Y(T, 1);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1000;
    //calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
    Dgp dgp_obj;
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat(1000, 1);//give 1000 replications
    int i = 1;
	#pragma omp parallel for default(shared) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,rseed)
	for (i = 1; i <= 1000; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_CMixedAR (X, Y, alpha, beta, lambda, 0., rseed);//draw two independent Gaussian random samples for X and Y
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        stat(i) = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, alpha, beta, lambda, sigma, seed);//calculate the t-test statistic
        size_out << stat(i) << endl;
	}
	Matrix cv(2,1);
	cv(1) = quantile (stat, 0.95);
	cv(2) = quantile (stat, 0.90);
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "5%-critical value for rho = " << 0. << " is " << cv(1) << endl;
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "10%-critical value for rho = " << 0. << " is " << cv(2) << endl;
	gsl_rng_free (r);
	return cv;
}

//calculate 5% and 10% empirical critical values when data are generated by a bivariate Student's t AR(2) process. INPUT: number of random samples
//generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha), AR slopes (beta and lambda),
//degrees of freedom (nu), standard deviations (sigma), a cdf value (cdfVal) set to 0.95 for a 5% critical value and 0.90 for a 10% critical value,
//a seed for random generators (seed), an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv)
template <double kernel (double)>
Matrix Power::cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, double nu, const Matrix &sigma, 
                      unsigned long seed, ofstream &size_out) {
	Matrix X(T, 1), Y(T, 1);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1000;
    //calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
    Dgp dgp_obj;
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat(1000, 1);//give 1000 replications
    int i = 1;
	#pragma omp parallel for default(shared) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,rseed)
	for (i = 1; i <= 1000; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_TMixedAR (X, Y, alpha, beta, lambda, nu, sigma, 0, rseed);//draw two independent Gaussian random samples for X and Y
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        stat(i) = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, alpha, beta, lambda, nu, sigma, seed);//calculate the t-test statistic
        size_out << stat(i) << endl;
	}
	Matrix cv(2,1); 
	cv(1) = quantile (stat, 0.95);
	cv(2) = quantile (stat, 0.90);
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "5%-critical value for rho = " << 0. << " is " << cv(1) << endl;
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "10%-critical value for rho = " << 0. << " is " << cv(2) << endl;
	gsl_rng_free (r);
	return cv;
}

//calculate 5% and 10% empirical critical values when X is generated by a Gaussian AR(2) process and Y is generated by a bivariate Gaussian AR(2) process.
//INPUT: a lag truncation (TL), a lag-smoothing parameter (lag_smooth), a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y), 
//3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms (sigma(1) for X, and sigma(2) for the error term (xi) of Y), 
//a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a seed for random generators (seed), and an output file stream (pwr_out). 
//OUTPUT: 5%- and 10%- critical values (cv)
template <double kernel (double)>
Matrix Power::cValue (int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, double rho, 
                      unsigned long seed, ofstream &size_out) {
	Matrix X(T, 1), Y(T, 2), Y1(T, 1), Y2(T, 1), resid_X(T-2, 1), slope_X(3, 1), resid_Y1(T-2, 1), slope_Y1(3, 1), resid_Y2(T-2, 1), slope_Y2(3, 1), 
	       resid_Eta(T-2, 1);
	Matrix interc(3, 1), slope_AR1(3, 1), slope_AR2(3, 1), std_dev(3, 1);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1000;
    //calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
    Dgp dgp_obj;
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat(1000, 1);//give 1000 replications
    int i = 1, t = 1;
    double rho_hat = 0.;
	#pragma omp parallel for default(shared) schedule(dynamic,CHUNK) private(i,t) firstprivate(X,Y,Y1,Y2,rseed,resid_X,resid_Y1,resid_Y2,slope_X,slope_Y1,slope_Y2,interc,slope_AR1,slope_AR2,std_dev,resid_Eta,rho_hat)
	for (i = 1; i <= 1000; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_AR1 (X, Y1, Y2, alpha, beta, lambda, sigma, rho, 0., rseed);//draw two independent Gaussian random samples for X and Y := (Y1, Y2)
		dgp_obj.gen_Resid (resid_X, slope_X, X);//estimate the d.g.p of X
		dgp_obj.gen_Resid (resid_Y1, slope_Y1, Y1);//estimate the d.g.p of Y1
		dgp_obj.gen_Resid (resid_Y2, slope_Y2, Y2);//estimate the d.g.p of Y2
		interc(1) = slope_X(1);
		interc(2) = slope_Y1(1);
		interc(3) = slope_Y2(1);
		slope_AR1(1) = slope_X(2);
		slope_AR1(2) = slope_Y1(2);
		slope_AR1(3) = slope_Y2(2);
		slope_AR2(1) = slope_X(3);
		slope_AR2(2) = slope_Y1(3);
		slope_AR2(3) = slope_Y2(3);
		std_dev(1) = sqrt(variance (resid_X));
		std_dev(2) = sqrt(variance (resid_Y1));
		dgp_obj.gen_Resid (resid_Eta, rho_hat, std_dev(3), resid_Y1, resid_Y2);
		for (t = 1; t <= T; ++t) {
			Y(t, 1) = Y1(t);
			Y(t, 2) = Y2(t);
		}
		//cout << "iteration = " << i << endl;
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        stat(i) = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, interc, slope_AR1, slope_AR2, std_dev, rho_hat, seed);//calculate the t-test statistic
        size_out << stat(i) << endl;
	}
	Matrix cv(2,1);
	cv(1) = quantile (stat, 0.95);
	cv(2) = quantile (stat, 0.90);
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "5%-critical value for rho = " << 0. << " is " << cv(1) << endl;
	size_out << "T = " << T << " and M_T = " << lag_smooth  << ": " << "10%-critical value for rho = " << 0. << " is " << cv(2) << endl;
	gsl_rng_free (r);
	return cv;
}

//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when X is generated by a Gaussian AR(2) process and 
//Y is generated by a bivariate Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), 
//a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y), 3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms
//(sigma(1) for X, and sigma(2) for the error term (xi) of Y), a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, 
//a threshold value (threshold) to generate some dependence between X and Y, empirical critical values (empir_CV), asymptotic critical values (asymp_CV), 
//a seed to generate random variables (seed), a file output stream (pwr_out). 
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, const Matrix &, double, double, unsigned long ), double kernel (double)>
void Power::power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                     const Matrix &lambda, const Matrix &sigma, double rho, double threshold, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, 
					 ofstream &pwr_out)  {
	Matrix X(T, 1), Y(T, 2), Y1(T, 1), Y2(T, 1), resid_X(T-2, 1), slope_X(3, 1), resid_Y1(T-2, 1), slope_Y1(3, 1), resid_Y2(T-2, 1), slope_Y2(3, 1), 
	       resid_Eta(T-2, 1);
	Matrix interc(3, 1), slope_AR1(3, 1), slope_AR2(3, 1), std_dev(3, 1);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
	cout << "Calculating rejection frequencies for T = " << T << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV(1) << " , " << empir_CV(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV(1) << " , " << asymp_CV(2) << ")" << " ..." << endl;
	//calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
	int i = 1, t = 1, empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double rho_hat = 0., tvalue = 0.;
	Dgp_ *dgp_obj = nullptr;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i,t) firstprivate(X,Y,Y1,Y2,rseed,tvalue,resid_X,resid_Y1,resid_Y2,slope_X,slope_Y1,slope_Y2,interc,slope_AR1,slope_AR2,std_dev,resid_Eta,rho_hat)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r); //set a random seed for the random number generator
		(dgp_obj->*genData) (X, Y1, Y2, alpha, beta, lambda, sigma, rho, threshold, rseed);//draw two dependent Gaussian random samples for X and Y := (Y1, Y2)
		(dgp_obj->gen_Resid) (resid_X, slope_X, X);//estimate the d.g.p of X
		(dgp_obj->gen_Resid) (resid_Y1, slope_Y1, Y1);//estimate the d.g.p of Y1
		(dgp_obj->gen_Resid) (resid_Y2, slope_Y2, Y2);//estimate the d.g.p of Y2
		interc(1) = slope_X(1);
		interc(2) = slope_Y1(1);
		interc(3) = slope_Y2(1);
		slope_AR1(1) = slope_X(2);
		slope_AR1(2) = slope_Y1(2);
		slope_AR1(3) = slope_Y2(2);
		slope_AR2(1) = slope_X(3);
		slope_AR2(2) = slope_Y1(3);
		slope_AR2(3) = slope_Y2(3);
		std_dev(1) = sqrt(variance (resid_X));
		std_dev(2) = sqrt(variance (resid_Y1));
		(dgp_obj->gen_Resid) (resid_Eta, rho_hat, std_dev(3), resid_Y1, resid_Y2);
		for (t = 1; t <= T; ++t) {
			Y(t, 1) = Y1(t);
			Y(t, 2) = Y2(t);
		}
		//cout << "iteration = " << i << endl;
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        tvalue = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, interc, slope_AR1, slope_AR2, std_dev, rho_hat, seed);//calculate the t-test statistic
        pwr_out << tvalue << endl;
        if (tvalue >= empir_CV(1)) ++empir_REJ_5;//using 5%-critical value
        if (tvalue >= asymp_CV(1)) ++asymp_REJ_5;//using 5%-critical value
        if (tvalue >= empir_CV(2)) ++empir_REJ_10;//using 10%-critical value
        if (tvalue >= asymp_CV(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF(1) = ((double) empir_REJ_5/number_sampl);
	empir_REJF(2) = ((double) empir_REJ_10/number_sampl);
	asymp_REJF(1) = ((double) asymp_REJ_5/number_sampl);
	asymp_REJF(2) = ((double) asymp_REJ_10/number_sampl);
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% empirical reject frequencies for rho = " << rho << " are " 
	        << empir_REJF(1) << " and " << empir_REJF(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% asymptotic reject frequencies for rho = " << rho << " are " 
	        << asymp_REJF(1) << " and " << asymp_REJF(2) << endl;
	gsl_rng_free (r);
	delete dgp_obj;
}
					 	


//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
//AR slopes (beta and lambda), standard deviations (sigma), degree of cross-sectional dependence (rho), empirical critical values (empir_CV), 
//asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
template <double kernel (double)>
void Power::power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                     const Matrix &lambda, const Matrix &sigma, double rho, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out)  {
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
    Dgp dgp_obj;
	cout << "Calculating rejection frequencies..." << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV(1) << " , " << empir_CV(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV(1) << " , " << asymp_CV(2) << ")" << " ..." << endl;
	//calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
	Matrix X(T, 1), Y(T, 1);
	int i = 1, empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double tvalue = 0.;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,tvalue,rseed)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_MixedAR (X, Y, alpha, beta, lambda, rho, rseed);//draw two dependent random samples for X and Y
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        tvalue = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, alpha, beta, lambda, sigma, seed);//calculate the t-test statistics
        pwr_out << tvalue << endl;
        if (tvalue >= empir_CV(1)) ++empir_REJ_5;//using 5%-critical value
        if (tvalue >= asymp_CV(1)) ++asymp_REJ_5;//using 5%-critical value
        if (tvalue >= empir_CV(2)) ++empir_REJ_10;//using 10%-critical value
        if (tvalue >= asymp_CV(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF(1) = ((double) empir_REJ_5/number_sampl);
	empir_REJF(2) = ((double) empir_REJ_10/number_sampl);
	asymp_REJF(1) = ((double) asymp_REJ_5/number_sampl);
	asymp_REJF(2) = ((double) asymp_REJ_10/number_sampl);
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% empirical reject frequencies for rho = " << rho << " are " 
	        << empir_REJF(1) << " and " << empir_REJF(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% asymptotic reject frequencies for rho = " << rho << " are " 
	        << asymp_REJF(1) << " and " << asymp_REJF(2) << endl;
	gsl_rng_free (r);
}

//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate correlated Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
//AR slopes (beta and lambda), standard deviations (sigma), degree of cross-sectional dependence (rho), empirical critical values (empir_CV), 
//asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
template <double kernel (double)>
void Power::power_CAR (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                       const Matrix &lambda, const Matrix &sigma, double rho, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out)  {
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
    Dgp dgp_obj;
	cout << "Calculating rejection frequencies..." << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV(1) << " , " << empir_CV(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV(1) << " , " << asymp_CV(2) << ")" << " ..." << endl;
	//calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
	Matrix X(T, 1), Y(T, 1);
	int i = 1, empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double tvalue = 0.;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,tvalue,rseed)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_CMixedAR (X, Y, alpha, beta, lambda, rho, rseed);//draw two correlated Gaussian random samples for X and Y
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        tvalue = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, alpha, beta, lambda, sigma, seed);//calculate the t-test statistics
        pwr_out << tvalue << endl;
        if (tvalue >= empir_CV(1)) ++empir_REJ_5;//using 5%-critical value
        if (tvalue >= asymp_CV(1)) ++asymp_REJ_5;//using 5%-critical value
        if (tvalue >= empir_CV(2)) ++empir_REJ_10;//using 10%-critical value
        if (tvalue >= asymp_CV(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF(1) = ((double) empir_REJ_5/number_sampl);
	empir_REJF(2) = ((double) empir_REJ_10/number_sampl);
	asymp_REJF(1) = ((double) asymp_REJ_5/number_sampl);
	asymp_REJF(2) = ((double) asymp_REJ_10/number_sampl);
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% empirical reject frequencies for rho = " << rho << " are " 
	        << empir_REJF(1) << " and " << empir_REJF(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% asymptotic reject frequencies for rho = " << rho << " are " 
	        << asymp_REJF(1) << " and " << asymp_REJF(2) << endl;
	gsl_rng_free (r);
}


//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Student's t AR(2) process.
//INPUT: number of random samples generated (number_sampl), a lag truncation (TL), a lag-smoothing parameter (lag_smooth), intercepts (alpha),
//AR slopes (beta and lambda), degrees of freedom (nu), standard deviations (sigma), degree of cross-sectional dependence (rho), 
//empirical critical values (empir_CV), asymptotic critical values (asymp_CV), a seed to generate random variables (seed), an output file stream (pwr_out). 
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
template <double kernel (double)>
void Power::power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int TL, int lag_smooth, const Matrix &alpha, const Matrix &beta, 
                     const Matrix &lambda, double nu, const Matrix &sigma, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out)  {
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_taus;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
    Dgp dgp_obj;
	cout << "Calculating rejection frequencies..." << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV(1) << " , " << empir_CV(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV(1) << " , " << asymp_CV(2) << ")" << " ..." << endl;
	//calculate integrals of quadratic and quartic functions of the kernel weight
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dist_corr::integrate_Kernel <kernel> (&kernel_QDSum, &kernel_QRSum);
	cout << "kernel_QDSum and kernel_QRSum =" << kernel_QDSum << " , " << kernel_QRSum << endl;
	Matrix X(T, 1), Y(T, 1);
	int i = 1, empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double tvalue = 0.;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,tvalue,rseed)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_TMixedAR (X, Y, alpha, beta, lambda, nu, sigma, 1., rseed);//draw two dependent random samples for X and Y
		Dist_corr obj_dc (X,Y);//define an object for the class of test statistics
        tvalue = obj_dc.do_Test <kernel> (TL, lag_smooth, kernel_QRSum, alpha, beta, lambda, nu, sigma, seed);//calculate the t-test statistics
        pwr_out << tvalue << endl;
        if (tvalue >= empir_CV(1)) ++empir_REJ_5;//using 5%-critical value
        if (tvalue >= asymp_CV(1)) ++asymp_REJ_5;//using 5%-critical value
        if (tvalue >= empir_CV(2)) ++empir_REJ_10;//using 10%-critical value
        if (tvalue >= asymp_CV(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF(1) = ((double) empir_REJ_5/number_sampl);
	empir_REJF(2) = ((double) empir_REJ_10/number_sampl);
	asymp_REJF(1) = ((double) asymp_REJ_5/number_sampl);
	asymp_REJF(2) = ((double) asymp_REJ_10/number_sampl);
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% empirical reject frequencies for nu = " << nu << " are " 
	        << empir_REJF(1) << " and " << empir_REJF(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << lag_smooth << ": 5% and 10% asymptotic reject frequencies for nu = " << nu << " are " 
	        << asymp_REJF(1) << " and " << asymp_REJF(2) << endl;
	gsl_rng_free (r);
}


#endif

