#ifndef DEP_TESTS_H
#define DEP_TESTS_H

//#include <boost/numeric/conversion/cast.hpp>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_rng.h>
#include <asserts.h>
#include <kernel.h>
#include <dgp.h>
#include <matrix_ops2.h>

#include <shogun/mathematics/Math.h>
#include <shogun/mathematics/Statistics.h>
#include <shogun/lib/SGMatrix.h>
#include <shogun/lib/SGVector.h>
#include <shogun/util/iterators.h>
#include <shogun/mathematics/linalg/LinalgNamespace.h>

#include <nl_dgp.h>
#include <mgarch.h>

using namespace std;
using namespace shogun;
using namespace shogun::linalg;

class Dep_tests: public Dgp  {
	public:
		Dep_tests (){  }; //default constructor
		~Dep_tests () {  };//default destructor

		//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 2*bandW+1 degrees of freedom
        static Matrix asymp_CV_ChiSq (int bandW);

        //asymptotic 5%- and 10%- critical values of the chi-squared distribution with 2*(2*bandW + 1) degrees of freedom
        static Matrix asymp_CV_ChiSq2 (int bandW);

        //asymptotic 5%- and 10%- critical values of the chi-squared distribution with 4*(2*bandW + 1)  [= d_x d_y(2*bandW+1)] degrees of freedom
		static Matrix asymp_CV_ChiSq3 (int bandW);

		//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 9*(2*bandW + 1)  [= d_x*(d_x+1)*d_y(d_y+1)*(2*bandW+1) / 4] degrees of freedom
		static Matrix asymp_CV_ChiSq4 (int bandW);

		//asymptotic 5%- and 10%- critical values of a gamma distribution with the shape and scale defined in Robbins and Fisher (2015)
		static Matrix asymp_CV_Gamma (int bandW, int d_x, int d_y);



        //calculate Hong's (1996) spectral test. INPUT: a bandwidth number (bandW), column vectors of data (u and v). OUTPUT: a double number
        template <double kernel_k (double )>
        static double do_HongTest (const int bandW, const Matrix &u, const Matrix &v);
        //calculate Hong's (2001) ecf-based test statistic
        template <double kernel_k (double )>
        static double do_ECFTest (const int bandW, const Matrix &u, const Matrix &v);
        //calculate Haugh's (1976) Portmanteau test. INPUT: a bandwidth (M), column vectors of data (u and v). OUTPUT: a double number
        static double do_HaughTest (int bandW, const Matrix &u, const Matrix &v);
        //calculate El Himdi and Roy's test statistic. INPUT: a bandwidth (M), column vectors of data (u and v). OUTPUT: a double number
        static double do_ElHimdiRoyTest (int bandW, const Matrix &u, const Matrix &v);

        /* Compute El Himdi and Roy's (1997) test statistic */
		static double do_ElHimdiRoyTest (	int bandW,
											const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
											const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/);

		/* Compute Bouhaddioui and Roy's (2006) test statistic */
		template <double kernel_k (double )>
		static double do_BouhaddiouiRoy(int bandW,
										const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
										const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/);

		/* Compute El Himdi and Roy's (1997), Bouhaddioui and Roy's (2006), and Robbins and Fisher's (2015) test statistics */
		template <double kernel_k (double )>
		static std::tuple<double, double, double> do_ElHimdiBouhaddiouiRoy(	int bandW_er, int bandW_br,
																			const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
																			const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/);

		/*	Compute Tchahou and Duchesne's (2013) test statistic */
		static std::pair<double, double> do_TchahouDuchesne(int bandW,
															const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
															const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/);

        //calculate 5% and 10% empirical critical values when data are generated by a bivariate Gaussian AR(2) process. INPUT: a sample size (T),
        //a lag-smoothing parameter (bandW), intercepts (alpha), AR slopes (beta and lambda), and a seed for random generators (seed),
		//an output file stream (pwr_out). OUTPUT: 5%- and 10%- critical values (cv_Hong and cv_Haugh)
        template <double kernel_k (double)>
        void cValue (Matrix &cv_Hong, Matrix &cv_Haugh, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, unsigned long seed, ofstream &size_out);
       //calculate 5%- and 10%- asymptotic sizes and empirical critical values when each X or Y is generated by a non-Gaussian AR(2) process. INPUT: a number of  random samples
       //generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), 6x1 vectors of AR coefficients (alpha_X and alpha_Y),
       //5%- and 10%- asymptotic CV's (asymp_CV_Hong and asymp_CV_Haugh), a delta in (-1,1), a kernel weight (kernel), a data-generating process (gen_DGP), and an OLS estimator (est_DGP).
       //OUTPUT: 5%- and 10%- sizes (REJF_Hong, REJF_ECFTest and REJF_Haugh); 5%- and 10%- critical values (cv_Hong, cv_ECFTest and cv_Haugh)
        template <double kernel (double), void gen_DGP (Matrix &, Matrix &, const Matrix, const Matrix, const double, const double, const int, unsigned long),
                          void est_DGP (Matrix &, Matrix &, const Matrix)>
        static void cValue (Matrix &REJF_Hong, Matrix &REJF_ECFTest, Matrix &REJF_Haugh, Matrix &cv_Hong, Matrix &cv_ECFTest, Matrix &cv_Haugh,
                                        const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &asymp_CV_Hong, const Matrix &asymp_CV_Haugh, const int number_sampl, const int T,
                                        const int bandW, const double delta, unsigned long seed, ofstream &size_out);
         //calculate the 5%- and 10%- empirical critical values for El Himdi & Roy's test when X is generated by a Gaussian AR(2) process and Y is generated by a bivariate
         //Gaussian AR(2) process. INPUT: a sample size (T), a lag-smoothing parameter (bandW), a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y),
         //3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms (sigma(1) for X, and sigma(2) for the error term (xi) of Y),
         //a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a seed for random generators (seed), and an output file stream (pwr_out).
         //OUTPUT: 5%- and 10%- critical values (cv_ElHimdiRoy)
         static void cValue (Matrix &cv_ElHimdiRoy, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, double rho, unsigned long seed,
                            ofstream &size_out);
          //calculate the 5%- and 10%- empirical critical values for El Himdi & Roy's test when X and Y are generated by a univariate non-Gaussian AR(2) process and a bivariate non-Gaussian AR(2)
         //process respectively. INPUT: 6x1 vectors of AR coefficients (alpha_X) and 6x2 matrix of AR coefficients (alpha_Y), a 3x1 vector (delta) in (-1,1)^3, 5%- and 10%- asymptotic critical
          //values (asymp_CV_ElHimdiRoy), a number of random samples to be drawn (number_sampl), a sample size (T), a lag-smoothing parameter (bandW).
          //OUTPUT: 5%- and 10%- sizes and critical values (REJF_ElHimdiRoy and empir_CV_ElHimdiRoy)
          template <void gen_DGP (Matrix &, Matrix &, Matrix &, const Matrix, const Matrix, const Matrix &, const double, const double, const int, unsigned long),
                             void est_DGP (Matrix &, Matrix &, const Matrix)>
          static void cValue (Matrix &REJF_ElHimdiRoy, Matrix &empir_CV_ElHimdiRoy, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &delta,
                                           const Matrix &asymp_CV_ElHimdiRoy, const int number_sampl, const int T, const int bandW, unsigned long seed, ofstream &size_out);
         //calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Gaussian AR(2) process.
         //INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), intercepts (alpha),
         //AR slopes (beta and lambda), degree of cross-sectional dependence (rho), empirical critical values (empir_CV_Hong and empir_CV_Haugh),
         //asymptotic critical values (asymp_CV_Hong and asymp_CV_Haugh), a seed to generate random variables (seed), an output file stream (pwr_out).
         //OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_Hong and empir_REJF_Hong) and asymptotic rejection frequencies (asymp_REJF_Hong and asymp_REJF_Haugh)
         template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, double, unsigned long ), double kernel (double)>
         void power_f (Matrix &empir_REJF_Hong, Matrix &asymp_REJF_Hong, Matrix &empir_REJF_Haugh, Matrix &asymp_REJF_Haugh, int number_sampl, int T, int bandW,
                                  const Matrix &alpha, const Matrix &beta, const Matrix &lambda, double rho, Matrix empir_CV_Hong, Matrix asymp_CV_Hong, Matrix empir_CV_Haugh,
                                  Matrix asymp_CV_Haugh, unsigned long seed, ofstream &pwr_out);
          //calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when each X or Y is generated by a non-Gaussian AR(2) process.
          //INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW),6x1 vectors of AR coefficients (alpha_X and alpha_Y),
          //delta and rho in (-1,1), a choose_alt = 0 (independent), 1 (correlated), 2 (uncorrelated but dependent) or 3 (correlated and dependent) to generate dependence in the error terms,
          //a data-generating process (gen_DGP), and an OLS estimator (est_DGP), 5%- and 10%- empirical critical values (empir_CV_Hong, empir_CV_ECFTest and empir_CV_Haugh),
          //5%- and 10%- asymptotic critical values (asymp_CV_Hong, asymp_CV_ECFTest and asymp_CV_Haugh).
          //OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_Hong, empir_REJF_ECFTest and empir_REJF_Hong) and
          //asymptotic rejection frequencies (asymp_REJF_Hong, asymp_REJF_ECFTest and asymp_REJF_Haugh)
          template <double kernel_k (double ), void gen_DGP (Matrix &, Matrix &, const Matrix, const Matrix, const double, const double, const int, unsigned long),
                             void est_DGP (Matrix &, Matrix &, const Matrix)>
          static void power_f (Matrix &empir_REJF_Hong, Matrix &asymp_REJF_Hong, Matrix &empir_REJF_ECFTest, Matrix &asymp_REJF_ECFTest, Matrix &empir_REJF_Haugh,
                                             Matrix &asymp_REJF_Haugh, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &empir_CV_Hong, const Matrix &asymp_CV_Hong,
                                             const Matrix &empir_CV_ECFTest, const Matrix &asymp_CV_ECFTest, const Matrix &empir_CV_Haugh, const Matrix &asymp_CV_Haugh,
                                             const int number_sampl, const int T, const int bandW, const double delta, const double rho, const int choose_alt, unsigned long seed, ofstream &pwr_out);
	    //calculate the 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point for El Himdi & Roy's test when X is generated by
        //a Gaussian AR(2) process and Y is generated by a bivariate Gaussian AR(2) process.
        //INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), a 3x1 vector of intercepts (alpha(1) for X,
        //and alpha(2-3) for Y), 3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms (sigma(1) for X,
        //and sigma(2) for the error term (xi) of Y), a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a threshold value (threshold) to generate
        //some dependence between X and Y, empirical critical values (empir_CV), asymptotic critical values (asymp_CV), a seed to generate random variables (seed),
        //a file output stream (pwr_out). OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
        template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, const Matrix &, double, double, unsigned long )>
        static void power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda,
                             const Matrix &sigma, double rho, double threshold, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out);
          //calculate the 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point for El Himdi & Roy's test when X is generated by
          //a univariate non-Gaussian AR(2) process and Y is generated by a bivariate non-Gaussian AR(2) process.
          //INPUT: 6x1 vectors of AR coefficients (alpha_X) and 6x2 matrix of AR coefficients (alpha_Y), a 3x1 vector (delta) in (-1,1)^3, 5%- and 10%- empirical critical
          //values (empir_CV_HR), 5%- and 10%- asymptotic critical values (asymp_CV_HR), correlations between error terms (rho12 and rho13), an alternative hypothesis
          //(choose_alt = 0 (independent), = 1 (correlated), = 2 (uncorrelated but dependent), = 3 (correlated and dependent)), a number of random samples to be drawn (number_sampl),
          //a sample size (T), a lag-smoothing parameter (bandW).
          //OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_ElHimdiRoy) and asymptotic rejection frequencies (asymp_REJF_ElHimdiRoy)
          template <void gen_DGP (Matrix &, Matrix &, Matrix &, const Matrix, const Matrix, const Matrix &, const double, const double, const int, unsigned long),
                             void est_DGP (Matrix &, Matrix &, const Matrix)>
          static void power_f (Matrix &empir_REJF_ElHimdiRoy, Matrix &asymp_REJF_ElHimdiRoy, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &delta,
                                             const Matrix &empir_CV_HR, const Matrix &asymp_CV_HR, const double rho12, const double rho13, const int choose_alt, const int number_sampl,
                                             const int T, const int bandW, unsigned long seed, ofstream &pwr_out);

    protected:

    private:
        //calculate the Pearson cross-correlation with `lag' lags. INPUT: a number of lags (lag), column vectors of data (u and v). OUTPUT: a double number
        static double calcul_PearsonC (int lag, const Matrix &u, const Matrix &v);
        //calculate the joint empirical characteristic correlation between two sequences of residuals (\widehat{I}_{n}(j))
        static double calcul_ECFC (const int lag, const Matrix &u, const Matrix &v);

		//integrate quadratic and quartic functions of a kernel weight
        template <double kernel_k (double )>
        static void integrate_Kernel (double &kernel_QDSum, double &kernel_QRSum);
};

//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 2*bandW+1 degrees of freedom
Matrix Dep_tests::asymp_CV_ChiSq (int bandW) {
	Matrix cv(2, 1);
	switch (bandW) {
		case 3:
			cv(1) = 14.067;
			cv(2) = 12.017;
			break;
    	case 5:
    	    cv(1) = 19.68;
    	    cv(2) = 17.28;
    	    break;
		case 7:
			cv(1) = 24.996;
			cv(2) = 22.307;
			break;
    	case 10:
    		cv(1) = 32.67;
    	    cv(2) = 29.62;
    	    break;
    	case 20:
    		cv(1) = 55.76;
    	    cv(2) = 51.81;
    	    break;
    	case 25:
    		cv(1) = 67.50;
    	    cv(2) = 63.17;
    	    break;
    	default:
    		cout << "This bandwidth is not in the switch list.\n";
            break;
	}
	return cv;
}

//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 2*(2*bandW + 1)  [= d_x d_y(2*bandW+1)] degrees of freedom
Matrix Dep_tests::asymp_CV_ChiSq2 (int bandW) {
	Matrix cv(2, 1);
	switch (bandW) {
		case 3:
			cv(1) = 23.685;
			cv(2) = 21.064;
			break;
    	case 5:
    	    cv(1) = 33.92;
    	    cv(2) = 30.81;
    	    break;
		case 7:
			cv(1) = 43.773;
			cv(2) = 40.256;
			break;
    	case 10:
    		cv(1) = 58.12;
    	    cv(2) = 54.09;
    	    break;
    	case 20:
    		cv(1) = 104.139;
    	    cv(2) = 98.780;
    	    break;
    	case 25:
    		cv(1) = 124.342;
    	    cv(2) = 118.498;
    	    break;
    	default:
    		cout << "This bandwidth is not in the switch list.\n";
            break;
	}
	return cv;
}

//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 4*(2*bandW + 1)  [= d_x d_y(2*bandW+1)] degrees of freedom
Matrix Dep_tests::asymp_CV_ChiSq3 (int bandW) {
	Matrix cv(2, 1);
	switch (bandW) {
		case 3:
			cv(1) = 41.337;
			cv(2) = 37.916;
			break;
    	case 5:
    	    cv(1) = 60.481;
    	    cv(2) = 56.369;
    	    break;
		case 7:
			cv(1) = 79.082;
			cv(2) = 74.397;
			break;
    	case 10:
    		cv(1) = 106.395;
    	    cv(2) = 100.980;
    	    break;
    	case 20:
    		cv(1) = 194.883;
    	    cv(2) = 187.596;
    	    break;
    	case 25:
    		cv(1) = 238.322;
    	    cv(2) = 230.276;
    	    break;
    	default:
    		cout << "This bandwidth is not in the switch list.\n";
            break;
	}
	return cv;
}

//asymptotic 5%- and 10%- critical values of the chi-squared distribution with 9*(2*bandW + 1)  [= d_x*(d_x+1)*d_y(d_y+1)*(2*bandW+1) / 4] degrees of freedom
Matrix Dep_tests::asymp_CV_ChiSq4 (int bandW) {
	Matrix cv(2, 1);
	switch (bandW) {
		case 3:
			cv(1) = 82.529;
			cv(2) = 77.745;
			break;
    	case 5:
    	    cv(1) = 123.225;
    	    cv(2) = 117.407;
    	    break;
		case 7:
			cv(1) = 163.116;
			cv(2) = 135;
			break;
    	case 10:
    		cv(1) = 222.076;
    	    cv(2) = 214.305;
    	    break;
    	case 20:
    		cv(1) = 414.792;
    	    cv(2) = 404.215;
    	    break;
    	case 25:
    		cv(1) = 509.947;
    	    cv(2) = 498.232;
    	    break;
    	default:
    		cout << "This bandwidth is not in the switch list.\n";
            break;
	}
	return cv;
}

//asymptotic 5%- and 10%- critical values of a gamma distribution with the shape and scale defined in Robbins and Fisher (2015)
Matrix Dep_tests::asymp_CV_Gamma (int bandW, int d_x, int d_y) {
	double K1 = d_x * d_y * (bandW+1);
	double K2 = 2 * d_x * d_y * (bandW*(2*bandW+1) / ( 3*(bandW+1) ) + 1);
	double shape = pow(K1, 2.) / K2, scal = K2 / K1;

	Matrix cv(2,1);
	cv(1) = gsl_cdf_gamma_Qinv(0.05, shape, scal);
	cv(2) = gsl_cdf_gamma_Qinv(0.10, shape, scal);
	return cv;
}

//integrate quadratic and quartic functions of a kernel weight
template <double kernel_k (double )>
void Dep_tests::integrate_Kernel (double &kernel_QDSum, double &kernel_QRSum) {
	double x = 0.;
	kernel_QDSum = 0.;
	kernel_QRSum = 0.;
	int t = 1, N = 500000;
	gsl_rng *r = nullptr;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, 3525364362);
	while (t <= N) {
		x =  60 * gsl_rng_uniform(r) - 30; //integral over the range [-30, 30]
		kernel_QDSum += 60 * ((double) 1/N) * pow(kernel_k (x), 2.);
		kernel_QRSum += 60 * ((double) 1/N) * pow(kernel_k (x), 4.);
		++t;
	}
	gsl_rng_free (r);
}


/* Compute El Himdi and Roy's (1997) test statistic */
double Dep_tests::do_ElHimdiRoyTest (	int bandW,
										const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
										const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/) {
	int T = eta1.num_rows, d1 = eta1.num_cols, d2 = eta2.num_cols;
	ASSERT_(T == eta2.num_rows);

	SGMatrix<double> cov11(d1, d1), cov22(d2, d2), cov12(d1, d2), diag_mat11(d1, d1), diag_mat22(d2, d2);
	SGMatrix<double> R11(d1, d1), R22(d2, d2), R12(d1, d2);
	SGVector<double> R12_vec(d1*d2);

	// Compute autocovariances at lag zero
	cov11 = cross_cov(eta1, eta1, 0);
	cov22 = cross_cov(eta2, eta2, 0);
	diag_mat11 = create_diagonal_matrix( inv_sqrt_vector( cov11.get_diagonal_vector() ) );
	diag_mat22 = create_diagonal_matrix( inv_sqrt_vector( cov22.get_diagonal_vector() ) );
	R11 = matrix_prod( diag_mat11, matrix_prod(cov11, diag_mat11) );
	R22 = matrix_prod( diag_mat22, matrix_prod(cov22, diag_mat22) );

	double stat = 0.;
	for (int m = -bandW; m <= bandW; ++m) {
		// Compute cross-covariances at lag 'm'
		cov12 = cross_cov(eta1, eta2, m);
		R12 = matrix_prod( diag_mat11, matrix_prod(cov12, diag_mat22) );
		R12_vec = vec(R12);
		stat += T * dot( R12_vec, matrix_prod( Kronecker( pinv<double>(R22), pinv<double>(R11) ), R12_vec ) );
	}
	return stat;
}

/* Compute Bouhaddioui and Roy's (2006) test statistic */
template <double kernel_k (double )>
double Dep_tests::do_BouhaddiouiRoy(int bandW,
									const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
									const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/) {
	int T = eta1.num_rows, d1 = eta1.num_cols, d2 = eta2.num_cols;
	ASSERT_(T == eta2.num_rows);

	SGMatrix<double> cov11(d1, d1), cov22(d2, d2), cov12(d1, d2), diag_mat11(d1, d1), diag_mat22(d2, d2);
	SGMatrix<double> R11(d1, d1), R22(d2, d2), R12(d1, d2);
	SGVector<double> R12_vec(d1*d2);

	// Compute autocovariances at lag zero
	cov11 = cross_cov(eta1, eta1, 0);
	cov22 = cross_cov(eta2, eta2, 0);
	diag_mat11 = create_diagonal_matrix( inv_sqrt_vector( cov11.get_diagonal_vector() ) );
	diag_mat22 = create_diagonal_matrix( inv_sqrt_vector( cov22.get_diagonal_vector() ) );
	R11 = matrix_prod( diag_mat11, matrix_prod(cov11, diag_mat11) );
	R22 = matrix_prod( diag_mat22, matrix_prod(cov22, diag_mat22) );


	// Integrate the kernel function
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dep_tests::integrate_Kernel<kernel_k>(kernel_QDSum, kernel_QRSum);

	double stat = 0.;
	for (int m = 1-T; m <= T-1; ++m) {
		// Compute cross-covariances at lag 'm'
		cov12 = cross_cov(eta1, eta2, m);
		R12 = matrix_prod( diag_mat11, matrix_prod(cov12, diag_mat22) );
		R12_vec = vec(R12);
		stat += pow(kernel_k( (double) m / bandW ), 2.) * T * dot( R12_vec, matrix_prod( Kronecker( pinv<double>(R22), pinv<double>(R11) ), R12_vec ) );
	}

	return (stat - bandW*d1*d2*kernel_QDSum) / sqrt(2*bandW*d1*d2*kernel_QRSum);
}

/* Compute El Himdi and Roy's (1997), Bouhaddioui and Roy's (2006), and Robbins and Fisher's (2015) test statistics */
template <double kernel_k (double )>
std::tuple<double, double, double> Dep_tests::do_ElHimdiBouhaddiouiRoy(	int bandW_er, int bandW_br,
																		const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
																		const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/) {
	int T = eta1.num_rows, d1 = eta1.num_cols, d2 = eta2.num_cols;
	ASSERT_(T == eta2.num_rows);

	SGMatrix<double> cov11(d1, d1), cov22(d2, d2), cov12(d1, d2), diag_mat11(d1, d1), diag_mat22(d2, d2);
	SGMatrix<double> R11(d1, d1), R22(d2, d2), R12(d1, d2);
	SGVector<double> R12_vec(d1*d2);

	// Compute autocovariances at lag zero
	cov11 = cross_cov(eta1, eta1, 0);
	cov22 = cross_cov(eta2, eta2, 0);
	diag_mat11 = create_diagonal_matrix( inv_sqrt_vector( cov11.get_diagonal_vector() ) );
	diag_mat22 = create_diagonal_matrix( inv_sqrt_vector( cov22.get_diagonal_vector() ) );
	R11 = matrix_prod( diag_mat11, matrix_prod(cov11, diag_mat11) );
	R22 = matrix_prod( diag_mat22, matrix_prod(cov22, diag_mat22) );


	// Integrate the kernel function
	double kernel_QDSum = 0., kernel_QRSum = 0.;
	Dep_tests::integrate_Kernel<kernel_k>(kernel_QDSum, kernel_QRSum);

	double Q_m = 0., er_stat = 0., rf_stat = 0., br_stat = 0.;
	for (int m = 2-T; m <= T-2; ++m) {
		// Compute cross-covariances at lag 'm'
		cov12 = cross_cov(eta1, eta2, m);
		R12 = matrix_prod( diag_mat11, matrix_prod(cov12, diag_mat22) );
		R12_vec = vec(R12);
		Q_m = dot( R12_vec, matrix_prod( Kronecker( pinv<double>(R22), pinv<double>(R11) ), R12_vec ) );
		if ( (m >= -bandW_er) && (m <= bandW_er) ) {
			er_stat += T * Q_m;
			rf_stat += T * ( ( bandW_er + 1 - fabs(m) ) * T / ( (bandW_er + 1) * ( T - fabs(m) ) ) ) * Q_m;
		}
		br_stat += pow(kernel_k( (double) m / bandW_br ), 2.) * T * Q_m;
	}

	return {er_stat, (br_stat - bandW_br*d1*d2*kernel_QDSum) / sqrt(2*bandW_br*d1*d2*kernel_QRSum), rf_stat}; // return the EH stat, BR stat, and RF stat
}


//calculate the Pearson cross-correlation with `lag' lags. INPUT: a number of lags (lag), column vectors of data (u and v). OUTPUT: a double number
double Dep_tests::calcul_PearsonC (int lag, const Matrix &u, const Matrix &v) {
    int T = 1, t = 1;
    T = u.nRow();
    ASSERT (T == v.nRow());
    double ave_u = 0., ave_v = 0., res = 0.;
    if (lag >= 0) {
        for (t = 1+lag; t <= T; ++t) {
            ave_u += ((double) 1/(T-lag)) * u(t);
            ave_v += ((double) 1/(T-lag)) * v(t);
        }
        for (t = 1+lag; t <= T; ++t) {
            res += ((double) 1/(T-lag)) * (u(t) - ave_u) * (v(t-lag) - ave_v);
        }
        return res;
    }
    else {
        for (t = 1-lag; t <= T; ++t) {
            ave_u += ((double) 1/(T+lag)) * u(t+lag);
            ave_v += ((double) 1/(T+lag)) * v(t+lag);
        }
        for (t = 1-lag; t <= T; ++t) {
            res += ((double) 1/(T+lag)) * (u(t+lag) - ave_u) * (v(t) - ave_v);
        }
        return res;
    }
}

/*	Compute Tchahou and Duchesne's (2013) test statistic */
std::pair<double, double> Dep_tests::do_TchahouDuchesne(int bandW,
														const SGMatrix<double> &eta1, /*T by d1 vector of residuals*/
														const SGMatrix<double> &eta2 /*T by d2 vector of residuals*/) {
	int T = eta1.num_rows, d1 = eta1.num_cols, d2 = eta2.num_cols;
	ASSERT_(T == eta2.num_rows);

	// compute squared residuals
	SGVector<double> q1(T), q2(T);
	for (int t = 0; t < T; ++t) {
		q1[t] = dot( eta1.get_row_vector(t), eta1.get_row_vector(t) );
		q2[t] = dot( eta2.get_row_vector(t), eta2.get_row_vector(t) );
	}

	// compute products of residuals
	SGMatrix<double> psi1(d1*(d1+1)/2, T), psi2(d2*(d2+1)/2, T), eta1_t(d1, 1), eta2_t(d2, 1);
	SGMatrix<double> psi1_t(d1, d1), psi2_t(d2, d2);
	for (int t = 0; t < T; ++t) {
		eta1_t.set_column( 0, eta1.get_row_vector(t) );
		psi1_t = matrix_prod(eta1_t, eta1_t, false, true);
		psi1.set_column( t, vech(psi1_t) );

		eta2_t.set_column( 0, eta2.get_row_vector(t) );
		psi2_t = matrix_prod(eta2_t, eta2_t, false, true);
		psi2.set_column( t, vech(psi2_t) );
	}

	psi1 = transpose_matrix(psi1);
	psi2 = transpose_matrix(psi2);

	// compute variance-covariance matrices
	SGMatrix<double> cov11(d1*(d1+1)/2, d1*(d1+1)/2), cov22(d2*(d2+1)/2, d2*(d2+1)/2), cov12(d1*(d1+1)/2, d2*(d2+1)/2);
	cov11 = cross_cov(psi1, psi1, 0);
	cov22 = cross_cov(psi2, psi2, 0);

	// compute the L1 test
	double L1 = 0., T1 = 0.;
	for (int m = -bandW; m <= bandW; ++m) {
		L1 += T * pow(cross_corr(q1, q2, m), 2.);

		cov12 = cross_cov(psi1, psi2, m);
		T1 += T * trace( matrix_prod( matrix_prod(cov12, pinv<double>(cov11), true, false), matrix_prod( cov12, pinv<double>(cov22) ) ) );
	}

	return {L1, T1};
}

//calculate the joint empirical characteristic correlation between two sequences of residuals (\widehat{I}_{n}(j))
double Dep_tests::calcul_ECFC (const int lag, const Matrix &u, const Matrix &v) {
    int T = u.nRow();
    ASSERT (T == v.nRow());
    //define trigonometric functions
    auto a_xy = [=] (double x, double y) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += cos(x*u(t) + y*v(t-lag)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += cos(x*u(t+lag) + y*v(t)) / (T+lag);
            }
        }
        return res;
    };
    auto b_xy = [=] (double x, double y) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += sin(x*u(t) + y*v(t-lag)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += sin(x*u(t+lag) + y*v(t)) / (T+lag);
            }
        }
        return res;
    };
    auto a_x = [=] (double x) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += cos(x*u(t)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += cos(x*u(t+lag)) / (T+lag);
            }
        }
        return res;
    };
    auto b_x = [=] (double x) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += sin(x*u(t)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += sin(x*u(t+lag)) / (T+lag);
            }
        }
        return res;
    };
    auto c_y = [=] (double y) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += cos(y*v(t-lag)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += cos(y*v(t)) / (T+lag);
            }
        }
        return res;
    };
    auto d_y = [=] (double y) {
        double res = 0.;
        if (lag >= 0) {
            for (auto t = 1+lag; t <= T; ++t) {
                res += sin(y*v(t-lag)) / (T-lag);
            }
        }
        else {
            for (auto t = 1-lag; t <= T; ++t) {
                res += sin(y*v(t)) / (T+lag);
            }
        }
        return res;
    };
    //do Monte-Carlo integration
    int N = 500; //number of draws
    unsigned long seed = 1535225;
    double x = 0., y = 0.;
    gsl_rng *r = nullptr;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    double res_I = 0.;
    int n = N;
    while (n-- > 0) { //repeat n times
          x = gsl_ran_ugaussian (r);  //draw two independent standard Gaussian random variables
          y = gsl_ran_ugaussian (r);
          res_I += (pow(a_xy(x, y) - a_x(x)*c_y(y) + b_x(x)*d_y(y), 2) + pow(b_xy(x, y) - a_x(x)*d_y(y) - b_x(x)*c_y(y), 2)) /N;
    }
    gsl_rng_free (r);
    return res_I;
}

//calculate Hong's (1996) spectral test. INPUT: a bandwidth number (bandW), column vectors of data (u and v). OUTPUT: a double number
template <double kernel_k (double )>
double Dep_tests::do_HongTest (const int bandW, const Matrix &u, const Matrix &v) {
	int T = 1;
    T = u.nRow();
    ASSERT (T == v.nRow());
	double prod_Var = 0.;
	prod_Var = sqrt(calcul_PearsonC(0, u, u) * calcul_PearsonC(0, v, v));
	int lag = 0;
	double weight = 0., corr = 0., num = 0., denom = 0.;
	#pragma omp parallel for default(shared) reduction (+:num,denom) schedule(dynamic,CHUNK) firstprivate(weight,corr) private(lag)
	for (lag = 1-T; lag <= T-1; ++lag) {
		weight = kernel_k ((double) lag/bandW);
		corr = calcul_PearsonC(lag, u, v) / prod_Var;
		num += pow(weight*corr, 2.) * (T - fabs(lag)) - pow(weight, 2.);
		if ((lag > 1-T) && (lag < T-1)) {
			denom += 2 * pow(weight, 4.);
		}
	}
	return num/sqrt(denom);
}

//calculate Hong's (2001) ecf-based test statistic
template <double kernel_k (double )>
double Dep_tests::do_ECFTest (const int bandW, const Matrix &u, const Matrix &v) {
    int T = 1;
    T = u.nRow();
    ASSERT (T == v.nRow());
    auto a0_x = [=] (double x) {
        double res = 0.;
        for (int t = 1; t <= T; ++t) {
            res += cos(x*u(t)) / T;
        }
        return res;
    };
    auto b0_x = [=] (double x) {
        double res = 0.;
        for (int t = 1; t <= T; ++t) {
            res += sin(x*u(t)) / T;
        }
        return res;
    };
    auto c0_y = [=] (double y) {
        double res = 0.;
        for (int t = 1; t <= T; ++t) {
            res += cos(y*v(t)) / T;
        }
        return res;
    };
    auto d0_y = [=] (double y) {
        double res = 0.;
        for (int t = 1; t <= T; ++t) {
            res += sin(y*v(t)) / T;
        }
        return res;
    };
    //calculate \widehat{C}_{0} and \widehat{D}_{0} using a Monte-Carlo integration
    int N = 500; //number of draws
    unsigned long seed = 1535225;
    gsl_rng *r = nullptr;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    double x = 0., x_p = 0., C0_1 = 0., C0_2 = 0., D0_1 = 0., D0_2 = 0.;
    int n = N;
    while (n-- > 0) { //repeat n times
        x = gsl_ran_ugaussian (r);  //draw a standard Gaussian random variable
        C0_1 += (1 - pow(a0_x(x), 2.) - pow(b0_x(x), 2.)) / N;
        C0_2 += (1 - pow(c0_y(x), 2.) - pow(d0_y(x), 2.)) / N;
        x_p = gsl_ran_ugaussian (r); //draw another standard Gaussian random variable
        D0_1 += (pow(a0_x(x+x_p) - a0_x(x)*a0_x(x_p) + b0_x(x)*b0_x(x_p), 2.) + pow(b0_x(x+x_p) - a0_x(x)*b0_x(x_p) - a0_x(x_p)*b0_x(x), 2.)) / N;
        D0_2 += (pow(c0_y(x+x_p) - c0_y(x)*c0_y(x_p) + d0_y(x)*d0_y(x_p), 2.) + pow(d0_y(x+x_p) - c0_y(x)*d0_y(x_p) - c0_y(x_p)*d0_y(x), 2.)) / N;
    }
    auto C0 = C0_1*C0_2, D0 = D0_1*D0_2;
    //calculate the test statistic
    int lag = 0;
    double weight = 0., corr = 0., num = 0., denom = 0.;
    #pragma omp parallel for default(shared) reduction (+:num,denom) schedule(dynamic,CHUNK) firstprivate(weight,corr) private(lag)
	for (lag = 1-T; lag <= T-1; ++lag) {
		weight = kernel_k ((double) lag/bandW);
		corr = Dep_tests::calcul_ECFC (lag, u, v);
		num += pow(weight, 2.) * ((T-std::fabs(lag))*corr - C0);
		if ((lag > 1-T) && (lag < T-1)) {
            denom += 2*D0*pow(weight, 4.);
		}
	}
    gsl_rng_free (r);
    return num / sqrt(denom);
}

//calculate Haugh's (1976) Portmanteau test. INPUT: a bandwidth (M), column vectors of data (u and v). OUTPUT: a double number
double Dep_tests::do_HaughTest (int bandW, const Matrix &u, const Matrix &v) {
	int T = 1, lag = 1;
    T = u.nRow();
    ASSERT (T == v.nRow());
	double prod_Var = 0., corr = 0., res = 0.;
	prod_Var = sqrt(calcul_PearsonC(0, u, u) * calcul_PearsonC(0, v, v));
	#pragma omp parallel for default(shared) reduction (+:res) schedule(dynamic,CHUNK) firstprivate(corr) private(lag)
	for (lag = -bandW; lag <= bandW; ++lag) {
		corr = calcul_PearsonC(lag, u, v) / prod_Var;
		res += T * pow(corr, 2.);
	}
	return res;
}

//calculate El Himdi and Roy's test statistic. INPUT: a bandwidth (M), a T by du data matrix (u) and a T by dv data matrix (v). OUTPUT: a double number
double Dep_tests::do_ElHimdiRoyTest (int bandW, const Matrix &u, const Matrix &v) {
	int T = 1, du = 1, dv = 1, i = 1, lag = 0;
	T = u.nRow();
	du = u.nCol();
	dv = v.nCol();
	ASSERT (T == v.nRow());
	Matrix cov_U(du, du), cov_V(dv, dv), diag_U(du, du), diag_V(dv, dv);
	cov_U = cov (u);
	cov_V = cov (v);
	diag_U.set (0.);
	diag_V.set (0.);
	for (i = 1; i <= du; ++i) {
		diag_U(i,i) = pow (cov_U(i,i), -0.5);
	}
	for (i = 1; i <= dv; ++i) {
		diag_V(i,i) = pow (cov_V(i,i), -0.5);
	}
	Matrix corr_U(du, du), corr_V(dv, dv), weight_UV(du*dv, du*dv), weight_UV_INV(du*dv, du*dv);
	corr_U = diag_U * (cov_U * diag_U);//correlation matrix of U
	corr_V = diag_V * (cov_V * diag_V);//correlation matrix of V
	weight_UV = Kronecker (corr_V, corr_U);
	weight_UV_INV = inv(weight_UV);
	Matrix cov_UV(du, dv), corr_UV(du, dv), vec_Corr_UV(du*dv, 1);
	double res = 0.;
	#pragma omp parallel for default(shared) reduction (+:res) schedule(dynamic,CHUNK) firstprivate(cov_UV,corr_UV,vec_Corr_UV) private(lag)
	for (lag = -bandW; lag <= bandW; ++lag) {
		cov_UV = cross_Cov (u, v, lag);//covariance matrix
		corr_UV = diag_U * (cov_UV * diag_V);//correlation matrix
		vec_Corr_UV = vec (corr_UV);//vectorize the correlation matrix
		res += Tr(vec_Corr_UV) * (weight_UV_INV * vec_Corr_UV);
	}
	return T * res;
}

//calculate 5% and 10% empirical critical values when data are generated by a bivariate Gaussian AR(2) process. INPUT: a sample size (T),
//a lag-smoothing parameter (bandW), intercepts (alpha), AR slopes (beta and lambda), and a seed for random generators (seed), an output file stream (size_out).
//OUTPUT: 5%- and 10%- critical values (cv_Hong and cv_Haugh)
template <double kernel_k (double)>
void Dep_tests::cValue (Matrix &cv_Hong, Matrix &cv_Haugh, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, unsigned long seed,
                        ofstream &size_out) {
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1000;
    //Dgp dgp_obj; //construct an object of class `DGP'
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat_Hong(1000, 1), stat_Haugh(1000, 1);//give 1000 replications
    int i = 1;
    size_out << "HongTest" << " , " << "HaughTest" << endl;
    Matrix X(T, 1), Y(T, 1), resid_X(T-2, 1), resid_Y(T-2, 1), slope_X(3, 1), slope_Y(3, 1);
	#pragma omp parallel for default(shared) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,resid_X,resid_Y,slope_X,slope_Y,rseed)
	for (i = 1; i <= 1000; ++i) {
		rseed = gsl_rng_get (r);//assign a random seed
		Dgp::gen_CMixedAR (X, Y, alpha, beta, lambda, 0., rseed);//draw two independent Gaussian random samples for X and Y
		Dgp::gen_Resid (resid_X, slope_X, X);//estimate the d.g.p of X and calculate residuals
	    Dgp::gen_Resid (resid_Y, slope_Y, Y);//estimate the d.g.p of Y and calculate residuals
        stat_Hong(i) = Dep_tests::do_HongTest <kernel_k> (bandW, resid_X, resid_Y);//calculate Hong's (1996) spectral test
        stat_Haugh(i) = Dep_tests::do_HaughTest (bandW, resid_X, resid_Y);//calculate Haugh's (1976) Portmanteau test
        size_out << stat_Hong(i) << " , " << stat_Haugh(i) << endl;
	}
	cv_Hong(1) = quantile (stat_Hong, 0.95);
	cv_Hong(2) = quantile (stat_Hong, 0.90);
	cv_Haugh(1) = quantile (stat_Haugh, 0.95);
	cv_Haugh(2) = quantile (stat_Haugh, 0.90);
	size_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value of  for rho = " << 0. << " is " << cv_Hong(1) << endl;
	size_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for rho = " << 0. << " is " << cv_Hong(2) << endl;
	size_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value of  for rho = " << 0. << " is " << cv_Haugh(1) << endl;
	size_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for rho = " << 0. << " is " << cv_Haugh(2) << endl;
	gsl_rng_free (r);
}

//calculate 5%- and 10%- asymptotic sizes and empirical critical values when each X or Y is generated by a non-Gaussian AR(2) process. INPUT: a number of  random samples
//generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), 6x1 vectors of AR coefficients (alpha_X and alpha_Y),
//5%- and 10%- asymptotic CV's (asymp_CV_Hong and asymp_CV_Haugh), a delta in (-1,1), a kernel weight (kernel), a data-generating process (gen_DGP), and an OLS estimator (est_DGP).
//OUTPUT: 5%- and 10%- sizes (REJF_Hong, REJF_ECFTest and REJF_Haugh); 5%- and 10%- critical values (cv_Hong, cv_ECFTest and cv_Haugh)
template <double kernel (double), void gen_DGP (Matrix &, Matrix &, const Matrix, const Matrix, const double, const double, const int, unsigned long),
                   void est_DGP (Matrix &, Matrix &, const Matrix)>
void Dep_tests::cValue (Matrix &REJF_Hong, Matrix &REJF_ECFTest, Matrix &REJF_Haugh, Matrix &cv_Hong, Matrix &cv_ECFTest, Matrix &cv_Haugh, const Matrix &alpha_X,
                                         const Matrix &alpha_Y, const Matrix &asymp_CV_Hong, const Matrix &asymp_CV_Haugh, const int number_sampl, const int T,
                                         const int bandW, const double delta, unsigned long seed, ofstream &size_out) {
    gsl_rng * r = nullptr;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat_Hong(number_sampl,1), stat_ECFTest(number_sampl,1), stat_Haugh(number_sampl, 1);//give number_sampl replications
    int i = 1, asymp_REJ_Hong_5 = 0, asymp_REJ_Hong_10 = 0, asymp_REJ_ECFTest_5 = 0, asymp_REJ_ECFTest_10 = 0, asymp_REJ_Haugh_5 = 0, asymp_REJ_Haugh_10 = 0;
    size_out << "HongTest" << " , " << "ECFTest" << " , " << "HaughTest" << endl;
    Matrix X(T, 1), Y(T, 1), resid_X(T-2, 1), resid_Y(T-2, 1), alpha_X_hat(6,1), alpha_Y_hat(6,1);
	#pragma omp parallel for default(shared) \
	 reduction (+:asymp_REJ_Hong_5,asymp_REJ_Hong_10,asymp_REJ_ECFTest_5,asymp_REJ_ECFTest_10,asymp_REJ_Haugh_5,asymp_REJ_Haugh_10) \
	 schedule(dynamic,CHUNK) private(i) firstprivate(rseed,X,Y,resid_X,resid_Y,alpha_X_hat,alpha_Y_hat)
	for (i = 1; i <= number_sampl; ++i) {
          rseed = gsl_rng_get (r); //a random seed
		gen_DGP (X, Y, alpha_X, alpha_Y, delta, 0., 0, rseed); //draw two independent random samples from the dgp of X and Y each using a random seed
		//then use these samples to estimate the AR coefficients
		est_DGP (resid_X, alpha_X_hat, X);
		est_DGP (resid_Y, alpha_Y_hat, Y);
		//cout << alpha_X_hat(1) << " , " << alpha_Y_hat(1) << endl;
		//calculate the test statistic
          stat_Hong(i) = Dep_tests::do_HongTest <kernel> (bandW, resid_X, resid_Y); //calculate Hong's (1996) spectral test
          if (stat_Hong(i) >= asymp_CV_Hong(1)) ++asymp_REJ_Hong_5; //using 5%-critical value
          if (stat_Hong(i) >= asymp_CV_Hong(2)) ++asymp_REJ_Hong_10; //using 10%-critical value
          stat_ECFTest(i) = Dep_tests::do_ECFTest <kernel> (bandW, resid_X, resid_Y); //calculate Hong's (2001) ecf-based test
          if (stat_ECFTest(i) >= asymp_CV_Hong(1)) ++asymp_REJ_ECFTest_5; //using 5%-critical value
          if (stat_ECFTest(i) >= asymp_CV_Hong(2)) ++asymp_REJ_ECFTest_10; //using 10%-critical value
          stat_Haugh(i) = Dep_tests::do_HaughTest (bandW, resid_X, resid_Y); //calculate Haugh's (1976) Portmanteau test
          if (stat_Haugh(i) >= asymp_CV_Haugh(1)) ++asymp_REJ_Haugh_5; //using 5%-critical value
          if (stat_Haugh(i) >= asymp_CV_Haugh(2)) ++asymp_REJ_Haugh_10; //using 10%-critical value
          size_out << stat_Hong(i) << " , " << stat_ECFTest(i) << " , " << stat_Haugh(i) << endl;
	}
	REJF_Hong(1) = ((double) asymp_REJ_Hong_5 / number_sampl); //calculate sizes
	REJF_Hong(2) = ((double) asymp_REJ_Hong_10 / number_sampl);
	cv_Hong(1) = quantile (stat_Hong, 0.95);
	cv_Hong(2) = quantile (stat_Hong, 0.90);
	REJF_ECFTest(1) = ((double) asymp_REJ_ECFTest_5 / number_sampl); //calculate sizes
	REJF_ECFTest(2) = ((double) asymp_REJ_ECFTest_10 / number_sampl);
	cv_ECFTest(1) = quantile (stat_ECFTest, 0.95);
	cv_ECFTest(2) = quantile (stat_ECFTest, 0.90);
	REJF_Haugh(1) = ((double) asymp_REJ_Haugh_5 / number_sampl); //calculate sizes
	REJF_Haugh(2) = ((double) asymp_REJ_Haugh_10 / number_sampl);
	cv_Haugh(1) = quantile (stat_Haugh, 0.95);
	cv_Haugh(2) = quantile (stat_Haugh, 0.90);
	size_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value of  for delta = " << delta << " is " << cv_Hong(1) << endl;
	size_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for delta = " << delta << " is " << cv_Hong(2) << endl;
	size_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%- and 10%- sizes for delta = " << delta << " are "
                    << "(" << REJF_Hong(1) << " , " << REJF_Hong(2) << ")" << endl;
	size_out << "Hong's (2001) ecf-based test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value of  for delta = " << delta << " is " << cv_ECFTest(1) << endl;
	size_out << "Hong's (2001) ecf-based test: " << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for delta = " << delta << " is " << cv_ECFTest(2) << endl;
	size_out << "Hong's (2001) ecf-based test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%- and 10%- sizes for delta = " << delta << " are "
                    << "(" << REJF_ECFTest(1) << " , " << REJF_ECFTest(2) << ")" << endl;
	size_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value of  for delta = " << delta << " is " << cv_Haugh(1) << endl;
	size_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for delta = " << delta << " is " << cv_Haugh(2) << endl;
	size_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW  << ": " << "5%- and 10%- sizes for delta = " << delta << " are "
                    << "(" << REJF_Haugh(1) << " , " << REJF_Haugh(2) << ")" << endl;
	gsl_rng_free (r);
}


//calculate the 5%- and 10%- empirical critical values for El Himdi & Roy's test when X is generated by a Gaussian AR(2) process and Y is generated by a bivariate
//Gaussian AR(2) process. INPUT: a sample size (T), a lag-smoothing parameter (bandW), a 3x1 vector of intercepts (alpha(1) for X, and alpha(2-3) for Y),
//3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms (sigma(1) for X, and sigma(2) for the error term (xi) of Y),
//a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a seed for random generators (seed), and an output file stream (pwr_out).
//OUTPUT: 5%- and 10%- critical values (cv_ElHimdiRoy)
void Dep_tests::cValue (Matrix &cv_ElHimdiRoy, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda, const Matrix &sigma, double rho, unsigned long seed,
                      ofstream &size_out) {
	Matrix X(T, 1), Y1(T, 1), Y2(T, 1), resid_X(T-2, 1), slope_X(3, 1), resid_Y1(T-2, 1), slope_Y1(3, 1), resid_Y2(T-2, 1), slope_Y2(3, 1), resid_Y(T-2, 2);
	gsl_rng * r = nullptr;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1000;
    Dgp dgp_obj;
    cout << "Calculating empirical critical values ..." << endl;
    Matrix stat(1000, 1);//give 1000 replications
    int i = 1, t = 1;
	#pragma omp parallel for default(shared) schedule(dynamic,CHUNK) private(i,t) firstprivate(X,Y1,Y2,rseed,resid_X,resid_Y1,resid_Y2,resid_Y,slope_X,slope_Y1,slope_Y2)
	for (i = 1; i <= 1000; i++) {
		rseed = gsl_rng_get (r);
		dgp_obj.gen_AR1 (X, Y1, Y2, alpha, beta, lambda, sigma, rho, 0., rseed);//draw two independent Gaussian random samples for X and Y := (Y1, Y2)
		dgp_obj.gen_Resid (resid_X, slope_X, X);//estimate the d.g.p of X
		dgp_obj.gen_Resid (resid_Y1, slope_Y1, Y1);//estimate the d.g.p of Y1
		dgp_obj.gen_Resid (resid_Y2, slope_Y2, Y2);//estimate the d.g.p of Y2
		for (t = 1; t <= T-2; ++t) {
			resid_Y(t, 1) = resid_Y1(t);
			resid_Y(t, 2) = resid_Y2(t);
		}
		stat(i) = do_ElHimdiRoyTest (bandW, resid_X, resid_Y);//calculate El Himdi & Roy's test statistic
        size_out << stat(i) << endl;
	}
	cv_ElHimdiRoy(1) = quantile (stat, 0.95);
	cv_ElHimdiRoy(2) = quantile (stat, 0.90);
	size_out << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value for El Himdi & Roy's test is " << cv_ElHimdiRoy(1) << endl;
	size_out << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for El Himdi & Roy's test is " << cv_ElHimdiRoy(2) << endl;
	gsl_rng_free (r);
}

//calculate the 5%- and 10%- empirical critical values for El Himdi & Roy's test when X and Y are generated by a univariate non-Gaussian AR(2) process and a bivariate non-Gaussian AR(2)
//process respectively. INPUT: 6x1 vectors of AR coefficients (alpha_X) and 6x2 matrix of AR coefficients (alpha_Y), a 3x1 vector (delta) in (-1,1)^3, 5%- and 10%- asymptotic critical
//values (asymp_CV_ElHimdiRoy), a number of random samples to be drawn (number_sampl), a sample size (T), a lag-smoothing parameter (bandW).
//OUTPUT: 5%- and 10%- sizes and critical values (REJF_ElHimdiRoy and empir_CV_ElHimdiRoy)
template <void gen_DGP (Matrix &, Matrix &, Matrix &, const Matrix, const Matrix, const Matrix &, const double, const double, const int, unsigned long),
                   void est_DGP (Matrix &, Matrix &, const Matrix)>
void Dep_tests::cValue (Matrix &REJF_ElHimdiRoy, Matrix &empir_CV_ElHimdiRoy, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &delta,
                                         const Matrix &asymp_CV_ElHimdiRoy, const int number_sampl, const int T, const int bandW, unsigned long seed, ofstream &size_out) {
     auto i = 1, t = 1, size_alpha_X = alpha_X.nRow(), size_alpha_Y = alpha_Y.nRow();
     Matrix X(T,1), Y1(T,1), Y2(T,1), resid_X(T-2,1), alpha_X_hat(size_alpha_X,1), resid_Y1(T-2,1), alpha_Y1_hat(size_alpha_Y,1), resid_Y2(T-2,1), alpha_Y2_hat(size_alpha_Y,1),
                 resid_Y(T-2,2);
	gsl_rng *r = nullptr;
     const gsl_rng_type * gen;//random number generator
     gsl_rng_env_setup();
     gen = gsl_rng_default;
     r = gsl_rng_alloc(gen);
     gsl_rng_set(r, seed);
     unsigned long rseed = 1;
     cout << "Calculating empirical critical values ..." << endl;
     Matrix stat(number_sampl,1);
     int asymp_REJ_HR_5 = 0, asymp_REJ_HR_10 = 0;
	#pragma omp parallel for default(shared) reduction(+:asymp_REJ_HR_5,asymp_REJ_HR_10) schedule(dynamic,CHUNK) private(i,t) \
                                                                                                                   firstprivate(rseed,X,Y1,Y2,resid_X,resid_Y1,resid_Y2,resid_Y,alpha_X_hat,alpha_Y1_hat,alpha_Y2_hat)
     for (i = 1; i <= number_sampl; ++i) {
          rseed = gsl_rng_get (r); //get a random seed
          gen_DGP (X, Y1, Y2, alpha_X, alpha_Y, delta, 0., 0., 0, rseed); //draw two independent random samples from the dgp of X and Y each using a random seed
		//then use these samples to estimate the AR coefficients
		est_DGP (resid_X, alpha_X_hat, X);
		est_DGP (resid_Y1, alpha_Y1_hat, Y1);
		est_DGP (resid_Y2, alpha_Y2_hat, Y2);
		for (t = 1; t <= T-2; ++t) {
			resid_Y(t,1) = resid_Y1(t); //collect all the residuals of Y1 and Y2 into a matrix
			resid_Y(t,2) = resid_Y2(t);
		}
		stat(i) = do_ElHimdiRoyTest (bandW, resid_X, resid_Y);//calculate El Himdi & Roy's test statistic
		size_out << stat(i) << endl;
          if (stat(i) >= asymp_CV_ElHimdiRoy(1)) ++asymp_REJ_HR_5; //using 5%-critical value
          if (stat(i) >= asymp_CV_ElHimdiRoy(2)) ++asymp_REJ_HR_10; //using 10%-critical value
	}
	REJF_ElHimdiRoy(1) = ((double) asymp_REJ_HR_5 / number_sampl); //calculate sizes
	REJF_ElHimdiRoy(2) = ((double) asymp_REJ_HR_10 / number_sampl);
	empir_CV_ElHimdiRoy(1) = quantile (stat, 0.95); //calculate empirical critical values
	empir_CV_ElHimdiRoy(2) = quantile (stat, 0.90);
	size_out << "T = " << T << " and M_T = " << bandW  << ": " << "5%-critical value for El Himdi & Roy's test is " << empir_CV_ElHimdiRoy(1) << endl;
	size_out << "T = " << T << " and M_T = " << bandW  << ": " << "10%-critical value for El Himdi & Roy's test is " << empir_CV_ElHimdiRoy(2) << endl;
	size_out << "T = " << T << " and M_T = " << bandW  << ": " << "5%- and 10%- sizes of El Himdi & Roy's test are " << REJF_ElHimdiRoy(1) << " and " << REJF_ElHimdiRoy(2) << endl;
	gsl_rng_free (r);
}

//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when data are generated by a bivariate Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), intercepts (alpha),
//AR slopes (beta and lambda), degree of cross-sectional dependence (rho), empirical critical values (empir_CV_Hong and empir_CV_Haugh),
//asymptotic critical values (asymp_CV_Hong and asymp_CV_Haugh), a seed to generate random variables (seed), an output file stream (pwr_out).
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_Hong and empir_REJF_Hong) and asymptotic rejection frequencies (asymp_REJF_Hong and asymp_REJF_Haugh)
template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, double, unsigned long ), double kernel_k (double )>
void Dep_tests::power_f (Matrix &empir_REJF_Hong, Matrix &asymp_REJF_Hong, Matrix &empir_REJF_Haugh, Matrix &asymp_REJF_Haugh, int number_sampl, int T, int bandW,
                         const Matrix &alpha, const Matrix &beta, const Matrix &lambda, double rho, Matrix empir_CV_Hong, Matrix asymp_CV_Hong,
						 Matrix empir_CV_Haugh, Matrix asymp_CV_Haugh, unsigned long seed, ofstream &pwr_out)  {
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
	cout << "Calculating rejection frequencies..." << endl;
	cout << "Hong's (1996) spectral test: empirical 5%- and 10%- critical values = " << "(" << empir_CV_Hong(1) << " , " << empir_CV_Hong(2) << ")" << " ..." << endl;
	cout << "Hong's (1996) spectral test: asymptotic 5%- and 10%- critical values = " << "(" << asymp_CV_Hong(1) << " , " << asymp_CV_Hong(2) << ")" << " ..." << endl;
	cout << "Haugh's (1976) Portmanteau test: empirical 5%- and 10%- critical values = " << "(" << empir_CV_Haugh(1) << " , " << empir_CV_Haugh(2) << ")" << " ..." << endl;
	cout << "Haugh's (1976) Portmanteau test: asymptotic 5%- and 10%- critical values = " << "(" << asymp_CV_Haugh(1) << " , " << asymp_CV_Haugh(2) << ")" << " ..." << endl;
	int i = 1, empir_REJ_Hong_5 = 0, asymp_REJ_Hong_5 = 0, empir_REJ_Hong_10 = 0, asymp_REJ_Hong_10 = 0;
	int empir_REJ_Haugh_5 = 0, asymp_REJ_Haugh_5 = 0, empir_REJ_Haugh_10 = 0, asymp_REJ_Haugh_10 = 0;
	double tvalue_Hong = 0., tvalue_Haugh = 0.;
	pwr_out << "HongTest" << " , " << "HaughTest" << endl;
	Dgp_ *dgp_obj = nullptr;//create a null pointer to a Dgp object
	Matrix X(T, 1), Y(T, 1), resid_X(T-2, 1), resid_Y(T-2, 1), slope_X(3, 1), slope_Y(3, 1);
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_Hong_5,empir_REJ_Hong_10,asymp_REJ_Hong_5,asymp_REJ_Hong_10,empir_REJ_Haugh_5,empir_REJ_Haugh_10,asymp_REJ_Haugh_5,asymp_REJ_Haugh_10) schedule(dynamic,CHUNK) private(i) firstprivate(X,Y,resid_X,resid_Y,slope_X,slope_Y,tvalue_Hong,tvalue_Haugh,rseed)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);//assign a random seed
		(dgp_obj->*genData) (X, Y, alpha, beta, lambda, rho, rseed);//draw two dependent random samples for X and Y
		(dgp_obj->gen_Resid) (resid_X, slope_X, X);//estimate the d.g.p of X and calculate residuals
	    (dgp_obj->gen_Resid) (resid_Y, slope_Y, Y);//estimate the d.g.p of Y and calculate residuals
        tvalue_Hong = Dep_tests::do_HongTest <kernel_k> (bandW, resid_X, resid_Y);//calculate Hong's (1996) spectral test
        if (tvalue_Hong >= empir_CV_Hong(1)) ++empir_REJ_Hong_5;//using 5%-critical value
        if (tvalue_Hong >= asymp_CV_Hong(1)) ++asymp_REJ_Hong_5;//using 5%-critical value
        if (tvalue_Hong >= empir_CV_Hong(2)) ++empir_REJ_Hong_10;//using 10%-critical value
        if (tvalue_Hong >= asymp_CV_Hong(2)) ++asymp_REJ_Hong_10;//using 10%-critical value
        tvalue_Haugh = Dep_tests::do_HaughTest (bandW, resid_X, resid_Y);//calculate Haugh's (1976) Portmanteau test
        pwr_out << tvalue_Hong << " , " << tvalue_Haugh << endl;
        if (tvalue_Haugh >= empir_CV_Haugh(1)) ++empir_REJ_Haugh_5;//using 5%-critical value
        if (tvalue_Haugh >= asymp_CV_Haugh(1)) ++asymp_REJ_Haugh_5;//using 5%-critical value
        if (tvalue_Haugh >= empir_CV_Haugh(2)) ++empir_REJ_Haugh_10;//using 10%-critical value
        if (tvalue_Haugh >= asymp_CV_Haugh(2)) ++asymp_REJ_Haugh_10;//using 10%-critical value
	}
	/* Hong's (1996) spectral test: Rejection rates */
	empir_REJF_Hong(1) = ((double) empir_REJ_Hong_5/number_sampl);
	empir_REJF_Hong(2) = ((double) empir_REJ_Hong_10/number_sampl);
	asymp_REJF_Hong(1) = ((double) asymp_REJ_Hong_5/number_sampl);
	asymp_REJF_Hong(2) = ((double) asymp_REJ_Hong_10/number_sampl);
	/* Haugh's (1976) Portmanteau test: Rejection rates */
	empir_REJF_Haugh(1) = ((double) empir_REJ_Haugh_5/number_sampl);
	empir_REJF_Haugh(2) = ((double) empir_REJ_Haugh_10/number_sampl);
	asymp_REJF_Haugh(1) = ((double) asymp_REJ_Haugh_5/number_sampl);
	asymp_REJF_Haugh(2) = ((double) asymp_REJ_Haugh_10/number_sampl);
	pwr_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW << ": empirical 5%- and 10%- reject frequencies for rho = " << rho << " are "
	        << empir_REJF_Hong(1) << " and " << empir_REJF_Hong(2) << endl;
	pwr_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW << ": asymptotic 5%- and 10%- reject frequencies for rho = " << rho << " are "
	        << asymp_REJF_Hong(1) << " and " << asymp_REJF_Hong(2) << endl;
	pwr_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW << ": empirical 5%- and 10%- reject frequencies for rho = " << rho << " are "
	        << empir_REJF_Haugh(1) << " and " << empir_REJF_Haugh(2) << endl;
	pwr_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW << ":  asymptotic 5%- and 10%- reject frequencies for rho = " << rho << " are "
	        << asymp_REJF_Haugh(1) << " and " << asymp_REJF_Haugh(2) << endl;
	gsl_rng_free (r);
    delete dgp_obj;
}

//calculate 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point when each X or Y is generated by a non-Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW),6x1 vectors of AR coefficients (alpha_X and alpha_Y),
//delta and rho in (-1,1), a choose_alt = 0 (independent), 1 (correlated), 2 (uncorrelated but dependent) or 3 (correlated and dependent) to generate dependence in the error terms,
//a data-generating process (gen_DGP), and an OLS estimator (est_DGP), 5%- and 10%- empirical critical values (empir_CV_Hong, empir_CV_ECFTest and empir_CV_Haugh),
//5%- and 10%- asymptotic critical values (asymp_CV_Hong, asymp_CV_ECFTest and asymp_CV_Haugh).
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_Hong, empir_REJF_ECFTest and empir_REJF_Hong) and
//asymptotic rejection frequencies (asymp_REJF_Hong, asymp_REJF_ECFTest and asymp_REJF_Haugh)
template <double kernel_k (double ), void gen_DGP (Matrix &, Matrix &, const Matrix, const Matrix, const double, const double, const int, unsigned long),
                   void est_DGP (Matrix &, Matrix &, const Matrix)>
void Dep_tests::power_f (Matrix &empir_REJF_Hong, Matrix &asymp_REJF_Hong, Matrix &empir_REJF_ECFTest, Matrix &asymp_REJF_ECFTest, Matrix &empir_REJF_Haugh,
                                            Matrix &asymp_REJF_Haugh, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &empir_CV_Hong, const Matrix &asymp_CV_Hong,
                                            const Matrix &empir_CV_ECFTest, const Matrix &asymp_CV_ECFTest, const Matrix &empir_CV_Haugh, const Matrix &asymp_CV_Haugh,
                                            const int number_sampl, const int T, const int bandW, const double delta, const double rho, const int choose_alt, unsigned long seed,
                                            ofstream &pwr_out)  {
     gsl_rng * r = nullptr;
     const gsl_rng_type * gen;//random number generator
     gsl_rng_env_setup();
     gen = gsl_rng_default;
     r = gsl_rng_alloc(gen);
     gsl_rng_set(r, seed);
     unsigned long rseed = 1;
	cout << "Calculating rejection frequencies..." << endl;
	cout << "Hong's (1996) spectral test: empirical 5%- and 10%- critical values = " << "(" << empir_CV_Hong(1) << " , " << empir_CV_Hong(2) << ")" << " ..." << endl;
	cout << "Hong's (1996) spectral test: asymptotic 5%- and 10%- critical values = " << "(" << asymp_CV_Hong(1) << " , " << asymp_CV_Hong(2) << ")" << " ..." << endl;
	cout << "Hong's (2001) ecf-based test: empirical 5%- and 10%- critical values = " << "(" << empir_CV_ECFTest(1) << " , " << empir_CV_ECFTest(2) << ")" << " ..." << endl;
	cout << "Hong's (2001) ecf-based test: asymptotic 5%- and 10%- critical values = " << "(" << asymp_CV_ECFTest(1) << " , " << asymp_CV_ECFTest(2) << ")" << " ..." << endl;
	cout << "Haugh's (1976) Portmanteau test: empirical 5%- and 10%- critical values = " << "(" << empir_CV_Haugh(1) << " , " << empir_CV_Haugh(2) << ")" << " ..." << endl;
	cout << "Haugh's (1976) Portmanteau test: asymptotic 5%- and 10%- critical values = " << "(" << asymp_CV_Haugh(1) << " , " << asymp_CV_Haugh(2) << ")" << " ..." << endl;
	int i = 1, empir_REJ_Hong_5 = 0, asymp_REJ_Hong_5 = 0, empir_REJ_Hong_10 = 0, asymp_REJ_Hong_10 = 0;
	int empir_REJ_ECFTest_5 = 0, asymp_REJ_ECFTest_5 = 0, empir_REJ_ECFTest_10 = 0, asymp_REJ_ECFTest_10 = 0;
	int empir_REJ_Haugh_5 = 0, asymp_REJ_Haugh_5 = 0, empir_REJ_Haugh_10 = 0, asymp_REJ_Haugh_10 = 0;
     auto tvalue_Hong = 0., tvalue_ECFTest = 0., tvalue_Haugh = 0.;
	pwr_out << "HongTest" << " , " << "ECFTest" << " , " << "HaughTest" << endl;
	Matrix X(T,1), Y(T,1), resid_X(T-2,1), resid_Y(T-2,1), alpha_X_hat(6,1), alpha_Y_hat(6,1);
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_Hong_5,empir_REJ_Hong_10,asymp_REJ_Hong_5,asymp_REJ_Hong_10,empir_REJ_ECFTest_5, \
               empir_REJ_ECFTest_10, asymp_REJ_ECFTest_5,asymp_REJ_ECFTest_10,empir_REJ_Haugh_5,empir_REJ_Haugh_10,asymp_REJ_Haugh_5,asymp_REJ_Haugh_10) \
	          schedule(dynamic,CHUNK) private(i) firstprivate(rseed,X,Y,resid_X,resid_Y,alpha_X_hat,alpha_Y_hat,tvalue_Hong,tvalue_ECFTest,tvalue_Haugh)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r); //a random seed
		gen_DGP (X, Y, alpha_X, alpha_Y, delta, rho, choose_alt, rseed); //draw two samples from the dgp of X and Y each using a random seed
		//then use these samples to estimate the AR coefficients
		est_DGP (resid_X, alpha_X_hat, X);
		est_DGP (resid_Y, alpha_Y_hat, Y);
         tvalue_Hong = Dep_tests::do_HongTest <kernel_k> (bandW, resid_X, resid_Y);//calculate Hong's (1996) spectral test
         if (tvalue_Hong >= empir_CV_Hong(1)) ++empir_REJ_Hong_5;//using 5%-critical value
         if (tvalue_Hong >= asymp_CV_Hong(1)) ++asymp_REJ_Hong_5;//using 5%-critical value
         if (tvalue_Hong >= empir_CV_Hong(2)) ++empir_REJ_Hong_10;//using 10%-critical value
         if (tvalue_Hong >= asymp_CV_Hong(2)) ++asymp_REJ_Hong_10;//using 10%-critical value
         tvalue_ECFTest = Dep_tests::do_ECFTest <kernel_k> (bandW, resid_X, resid_Y); //calculate Hong's (2001) ecf-based test
         if (tvalue_ECFTest >= empir_CV_ECFTest(1)) ++empir_REJ_ECFTest_5;//using 5%-critical value
         if (tvalue_ECFTest >= asymp_CV_ECFTest(1)) ++asymp_REJ_ECFTest_5;//using 5%-critical value
         if (tvalue_ECFTest >= empir_CV_ECFTest(2)) ++empir_REJ_ECFTest_10;//using 10%-critical value
         if (tvalue_ECFTest >= asymp_CV_ECFTest(2)) ++asymp_REJ_ECFTest_10;//using 10%-critical value
         tvalue_Haugh = Dep_tests::do_HaughTest (bandW, resid_X, resid_Y);//calculate Haugh's (1976) Portmanteau test
         pwr_out << tvalue_Hong << " , " << tvalue_ECFTest << " , " << tvalue_Haugh << endl;
         if (tvalue_Haugh >= empir_CV_Haugh(1)) ++empir_REJ_Haugh_5;//using 5%-critical value
         if (tvalue_Haugh >= asymp_CV_Haugh(1)) ++asymp_REJ_Haugh_5;//using 5%-critical value
         if (tvalue_Haugh >= empir_CV_Haugh(2)) ++empir_REJ_Haugh_10;//using 10%-critical value
         if (tvalue_Haugh >= asymp_CV_Haugh(2)) ++asymp_REJ_Haugh_10;//using 10%-critical value
	}
	/* Hong's (1996) spectral test: Rejection rates */
	empir_REJF_Hong(1) = ((double) empir_REJ_Hong_5 / number_sampl);
	empir_REJF_Hong(2) = ((double) empir_REJ_Hong_10 / number_sampl);
	asymp_REJF_Hong(1) = ((double) asymp_REJ_Hong_5 / number_sampl);
	asymp_REJF_Hong(2) = ((double) asymp_REJ_Hong_10 / number_sampl);
	/* Hong's (2001) ecf-based test: Rejection rates */
	empir_REJF_ECFTest(1) = ((double) empir_REJ_ECFTest_5 / number_sampl);
	empir_REJF_ECFTest(2) = ((double) empir_REJ_ECFTest_10 / number_sampl);
	asymp_REJF_ECFTest(1) = ((double) asymp_REJ_ECFTest_5 / number_sampl);
	asymp_REJF_ECFTest(2) = ((double) asymp_REJ_ECFTest_10 / number_sampl);
	/* Haugh's (1976) Portmanteau test: Rejection rates */
	empir_REJF_Haugh(1) = ((double) empir_REJ_Haugh_5 / number_sampl);
	empir_REJF_Haugh(2) = ((double) empir_REJ_Haugh_10 / number_sampl);
	asymp_REJF_Haugh(1) = ((double) asymp_REJ_Haugh_5 / number_sampl);
	asymp_REJF_Haugh(2) = ((double) asymp_REJ_Haugh_10 / number_sampl);
	pwr_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW << ": empirical 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << empir_REJF_Hong(1) << " and " << empir_REJF_Hong(2) << endl;
	pwr_out << "Hong's (1996) spectral test: " << "T = " << T << " and M_T = " << bandW << ": asymptotic 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << asymp_REJF_Hong(1) << " and " << asymp_REJF_Hong(2) << endl;
    pwr_out << "Hong's (2001) ecf-based test: " << "T = " << T << " and M_T = " << bandW << ": empirical 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << empir_REJF_ECFTest(1) << " and " << empir_REJF_ECFTest(2) << endl;
	pwr_out << "Hong's (2001) ecf-based test: " << "T = " << T << " and M_T = " << bandW << ": asymptotic 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << asymp_REJF_ECFTest(1) << " and " << asymp_REJF_ECFTest(2) << endl;
	pwr_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW << ": empirical 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << empir_REJF_Haugh(1) << " and " << empir_REJF_Haugh(2) << endl;
	pwr_out << "Haugh's (1976) Portmanteau test: " << "T = " << T << " and M_T = " << bandW << ":  asymptotic 5%- and 10%- reject frequencies for choose_alt = " << choose_alt << " are "
	               << asymp_REJF_Haugh(1) << " and " << asymp_REJF_Haugh(2) << endl;
	gsl_rng_free (r);
}


//calculate the 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point for El Himdi & Roy's test when X is generated by
//a univariate non-Gaussian AR(2) process and Y is generated by a bivariate non-Gaussian AR(2) process.
//INPUT: 6x1 vectors of AR coefficients (alpha_X) and 6x2 matrix of AR coefficients (alpha_Y), a 3x1 vector (delta) in (-1,1)^3, 5%- and 10%- empirical critical
//values (empir_CV_HR), 5%- and 10%- asymptotic critical values (asymp_CV_HR), correlations between error terms (rho12 and rho13), an alternative hypothesis
//(choose_alt = 0 (independent), = 1 (correlated), = 2 (uncorrelated but dependent), = 3 (correlated and dependent)), a number of random samples to be drawn (number_sampl),
//a sample size (T), a lag-smoothing parameter (bandW).
//OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF_ElHimdiRoy) and asymptotic rejection frequencies (asymp_REJF_ElHimdiRoy)
template <void gen_DGP (Matrix &, Matrix &, Matrix &, const Matrix, const Matrix, const Matrix &, const double, const double, const int, unsigned long),
                   void est_DGP (Matrix &, Matrix &, const Matrix)>
void Dep_tests::power_f (Matrix &empir_REJF_ElHimdiRoy, Matrix &asymp_REJF_ElHimdiRoy, const Matrix &alpha_X, const Matrix &alpha_Y, const Matrix &delta,
                                            const Matrix &empir_CV_HR, const Matrix &asymp_CV_HR, const double rho12, const double rho13, const int choose_alt, const int number_sampl,
                                            const int T, const int bandW, unsigned long seed, ofstream &pwr_out)  {
	auto i = 1, t = 1, size_alpha_X = alpha_X.nRow(), size_alpha_Y = alpha_Y.nRow();
     Matrix X(T,1), Y1(T,1), Y2(T,1), resid_X(T-2,1), alpha_X_hat(size_alpha_X,1), resid_Y1(T-2,1), alpha_Y1_hat(size_alpha_Y,1), resid_Y2(T-2,1), alpha_Y2_hat(size_alpha_Y,1),
                 resid_Y(T-2,2);
	gsl_rng *r = nullptr;
     const gsl_rng_type * gen;//random number generator
     gsl_rng_env_setup();
     gen = gsl_rng_default;
     r = gsl_rng_alloc(gen);
     gsl_rng_set(r, seed);
     unsigned long rseed = 1;
	cout << "Calculating rejection frequencies for T = " << T << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV_HR(1) << " , " << empir_CV_HR(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV_HR(1) << " , " << asymp_CV_HR(2) << ")" << " ..." << endl;
	int empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double tvalue = 0.;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i,t) \
	                                                                                                           firstprivate(rseed,X,Y1,Y2,tvalue,resid_X,resid_Y1,resid_Y2,resid_Y,alpha_X_hat,alpha_Y1_hat,alpha_Y2_hat)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);
		//draw two samples from the dgp of X and Y each using a random seed
		gen_DGP (X, Y1, Y2, alpha_X, alpha_Y, delta, rho12, rho13, choose_alt, rseed);
		//then use these samples to estimate the AR coefficients
		est_DGP (resid_X, alpha_X_hat, X);
		est_DGP (resid_Y1, alpha_Y1_hat, Y1);
		est_DGP (resid_Y2, alpha_Y2_hat, Y2);
		for (t = 1; t <= T-2; ++t) {
			resid_Y(t, 1) = resid_Y1(t);
			resid_Y(t, 2) = resid_Y2(t);
		}
		tvalue = do_ElHimdiRoyTest (bandW, resid_X, resid_Y);//calculate El Himdi & Roy's test statistic
          pwr_out << tvalue << endl;
          if (tvalue >= empir_CV_HR(1)) ++empir_REJ_5;//using 5%-critical value
          if (tvalue >= asymp_CV_HR(1)) ++asymp_REJ_5;//using 5%-critical value
          if (tvalue >= empir_CV_HR(2)) ++empir_REJ_10;//using 10%-critical value
          if (tvalue >= asymp_CV_HR(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF_ElHimdiRoy(1) = ((double) empir_REJ_5 / number_sampl);
	empir_REJF_ElHimdiRoy(2) = ((double) empir_REJ_10 / number_sampl);
	asymp_REJF_ElHimdiRoy(1) = ((double) asymp_REJ_5 / number_sampl);
	asymp_REJF_ElHimdiRoy(2) = ((double) asymp_REJ_10 / number_sampl);
	pwr_out << "T = " << T << " and M_T = " << bandW << ": 5% and 10% empirical reject frequencies for choose_alt= " << choose_alt << " are "
	        << empir_REJF_ElHimdiRoy(1) << " and " << empir_REJF_ElHimdiRoy(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << bandW << ": 5% and 10% asymptotic reject frequencies for choose_alt = " << choose_alt << " are "
	        << asymp_REJF_ElHimdiRoy(1) << " and " << asymp_REJF_ElHimdiRoy(2) << endl;
	gsl_rng_free (r);
}

//calculate the 5% and 10% empirical and asymptotic rejection frequencies at a cut-off point for El Himdi & Roy's test when X is generated by
//a univariate Gaussian AR(2) process and Y is generated by a bivariate Gaussian AR(2) process.
//INPUT: number of random samples generated (number_sampl), a sample size (T), a lag-smoothing parameter (bandW), a 3x1 vector of intercepts (alpha(1) for X,
//and alpha(2-3) for Y), 3x1 vectors of AR slopes (beta and lambda), a 2x1 vector of std. deviations of error terms (sigma(1) for X,
//and sigma(2) for the error term (xi) of Y), a correlation between \eta_1 and \eta_2 (rho) for the Y d.g.p, a threshold value (threshold) to generate
//some dependence between X and Y, empirical critical values (empir_CV), asymptotic critical values (asymp_CV), a seed to generate random variables (seed),
//a file output stream (pwr_out). OUTPUT: 5% and 10% empirical rejection frequencies (empir_REJF) and asymptotic rejection frequencies (asymp_REJF)
template <typename Dgp_, void (Dgp_::*genData) (Matrix &, Matrix &, Matrix &, const Matrix &, const Matrix &, const Matrix &, const Matrix &, double, double, unsigned long )>
void Dep_tests::power_f (Matrix &empir_REJF, Matrix &asymp_REJF, int number_sampl, int T, int bandW, const Matrix &alpha, const Matrix &beta, const Matrix &lambda,
                     const Matrix &sigma, double rho, double threshold, Matrix empir_CV, Matrix asymp_CV, unsigned long seed, ofstream &pwr_out)  {
	Matrix X(T, 1), Y1(T, 1), Y2(T, 1), resid_X(T-2, 1), slope_X(3, 1), resid_Y1(T-2, 1), slope_Y1(3, 1), resid_Y2(T-2, 1), slope_Y2(3, 1), resid_Y(T-2, 2);
	gsl_rng * r;
    const gsl_rng_type * gen;//random number generator
    gsl_rng_env_setup();
    gen = gsl_rng_default;
    r = gsl_rng_alloc(gen);
    gsl_rng_set(r, seed);
    unsigned long rseed = 1;
	cout << "Calculating rejection frequencies for T = " << T << endl;
	cout << "5%- and 10%- empirical critical values = " << "(" << empir_CV(1) << " , " << empir_CV(2) << ")" << " ..." << endl;
	cout << "5%- and 10%- asymptotic critical values = " << "(" << asymp_CV(1) << " , " << asymp_CV(2) << ")" << " ..." << endl;
	int i = 1, t = 1, empir_REJ_5 = 0, asymp_REJ_5 = 0, empir_REJ_10 = 0, asymp_REJ_10 = 0;
	double tvalue = 0.;
	Dgp_ *dgp_obj = nullptr;
	#pragma omp parallel for default(shared) reduction (+:empir_REJ_5,empir_REJ_10,asymp_REJ_5,asymp_REJ_10) schedule(dynamic,CHUNK) private(i,t) firstprivate(X,Y1,Y2,rseed,tvalue,resid_X,resid_Y1,resid_Y2,resid_Y,slope_X,slope_Y1,slope_Y2)
	for (i = 1; i <= number_sampl; i++) {
		rseed = gsl_rng_get (r);
		(dgp_obj->*genData) (X, Y1, Y2, alpha, beta, lambda, sigma, rho, threshold, rseed);//draw two dependent Gaussian random samples for X and Y := (Y1, Y2)
		(dgp_obj->gen_Resid) (resid_X, slope_X, X);//estimate the d.g.p of X
		(dgp_obj->gen_Resid) (resid_Y1, slope_Y1, Y1);//estimate the d.g.p of Y1
		(dgp_obj->gen_Resid) (resid_Y2, slope_Y2, Y2);//estimate the d.g.p of Y2
		for (t = 1; t <= T-2; ++t) {
			resid_Y(t, 1) = resid_Y1(t);
			resid_Y(t, 2) = resid_Y2(t);
		}
		tvalue = do_ElHimdiRoyTest (bandW, resid_X, resid_Y);//calculate El Himdi & Roy's test statistic
        pwr_out << tvalue << endl;
        if (tvalue >= empir_CV(1)) ++empir_REJ_5;//using 5%-critical value
        if (tvalue >= asymp_CV(1)) ++asymp_REJ_5;//using 5%-critical value
        if (tvalue >= empir_CV(2)) ++empir_REJ_10;//using 10%-critical value
        if (tvalue >= asymp_CV(2)) ++asymp_REJ_10;//using 10%-critical value
	}
	empir_REJF(1) = ((double) empir_REJ_5/number_sampl);
	empir_REJF(2) = ((double) empir_REJ_10/number_sampl);
	asymp_REJF(1) = ((double) asymp_REJ_5/number_sampl);
	asymp_REJF(2) = ((double) asymp_REJ_10/number_sampl);
	pwr_out << "T = " << T << " and M_T = " << bandW << ": 5% and 10% empirical reject frequencies for threshold = " << threshold << " are "
	        << empir_REJF(1) << " and " << empir_REJF(2) << endl;
	pwr_out << "T = " << T << " and M_T = " << bandW << ": 5% and 10% asymptotic reject frequencies for threshold = " << threshold << " are "
	        << asymp_REJF(1) << " and " << asymp_REJF(2) << endl;
	gsl_rng_free (r);
	delete dgp_obj;
}










#endif
